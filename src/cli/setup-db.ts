import { join } from "node:path";
import { runMigrations } from "../core/db/migrate.ts";
import type { SetupResult } from "../core/types/index.ts";
import { generateEncryptionKey } from "../core/utils/crypto.ts";
import { loadKeysEnv, parseEnvFile } from "../core/utils/env.ts";

/**
 * Provision a Neon database for the Personal Hub.
 * Uses neonctl CLI with API key (no browser required).
 * Resumes from failure: skips if config/hub.env already has DATABASE_URL.
 */
export async function setupDatabase(configDir = "config"): Promise<SetupResult> {
	const hubEnvPath = join(configDir, "hub.env");
	const hubFile = Bun.file(hubEnvPath);

	// Resume check: skip if already configured
	if (await hubFile.exists()) {
		const content = await hubFile.text();
		const env = parseEnvFile(content);
		if (env.DATABASE_URL) {
			return {
				step: "database",
				status: "skipped",
				message: "Database already configured in hub.env",
				data: { databaseUrl: maskUrl(env.DATABASE_URL) },
			};
		}
	}

	// Load Neon API key from keys.env
	const keysResult = await loadKeysEnv(configDir);
	if (!keysResult.success) {
		return {
			step: "database",
			status: "error",
			message: keysResult.error,
		};
	}

	const neonApiKey = keysResult.data.NEON_API_KEY;
	if (!neonApiKey) {
		return {
			step: "database",
			status: "error",
			message: "NEON_API_KEY not found in keys.env. Run key setup first.",
		};
	}

	// Check neonctl is installed
	try {
		const which = Bun.spawn(["which", "neonctl"], { stdout: "pipe", stderr: "pipe" });
		await which.exited;
		if (which.exitCode !== 0) {
			throw new Error("not found");
		}
	} catch {
		return {
			step: "database",
			status: "error",
			message: "neonctl CLI not found. Install it: npm i -g neonctl (or bun add -g neonctl)",
		};
	}

	// Create Neon project
	const suffix = Math.random().toString(36).slice(2, 8);
	const projectName = `psn-hub-${suffix}`;

	const proc = Bun.spawn(
		[
			"neonctl",
			"projects",
			"create",
			"--name",
			projectName,
			"--output",
			"json",
			"--api-key",
			neonApiKey,
		],
		{ stdout: "pipe", stderr: "pipe" },
	);

	const exitCode = await proc.exited;
	const stdout = await new Response(proc.stdout).text();
	const stderr = await new Response(proc.stderr).text();

	if (exitCode !== 0) {
		return {
			step: "database",
			status: "error",
			message: `neonctl failed: ${stderr.trim() || stdout.trim()}`,
		};
	}

	// Parse neonctl output to extract connection string
	let connectionUri: string;
	try {
		const output = JSON.parse(stdout);
		connectionUri = output.connection_uris?.[0]?.connection_uri ?? output.connection_uri ?? "";

		if (!connectionUri) {
			// Try alternative output format
			const dbUri = output.databases?.[0]?.connection_uri;
			if (dbUri) {
				connectionUri = dbUri;
			} else {
				return {
					step: "database",
					status: "error",
					message: `Could not extract connection URI from neonctl output. Raw: ${stdout.slice(0, 200)}`,
				};
			}
		}
	} catch {
		return {
			step: "database",
			status: "error",
			message: `Failed to parse neonctl output: ${stdout.slice(0, 200)}`,
		};
	}

	// Generate encryption key
	const encKey = generateEncryptionKey().toString("hex");

	// Write hub.env
	const hubEnvContent = [
		"# Personal Hub Configuration (auto-generated by /psn:setup)",
		`DATABASE_URL=${connectionUri}`,
		`HUB_ENCRYPTION_KEY=${encKey}`,
		"",
	].join("\n");

	await Bun.write(hubEnvPath, hubEnvContent);

	// Run migrations
	const migrateResult = await runMigrations(connectionUri);
	if (!migrateResult.success) {
		return {
			step: "database",
			status: "error",
			message: `Database created but migrations failed: ${migrateResult.error}. hub.env saved â€” re-run setup to retry migrations.`,
			data: { projectName, databaseUrl: maskUrl(connectionUri) },
		};
	}

	return {
		step: "database",
		status: "success",
		message: `Database "${projectName}" created, migrations applied`,
		data: { projectName, databaseUrl: maskUrl(connectionUri) },
	};
}

function maskUrl(url: string): string {
	try {
		const parsed = new URL(url);
		parsed.password = "***";
		return parsed.toString();
	} catch {
		return "***masked***";
	}
}
