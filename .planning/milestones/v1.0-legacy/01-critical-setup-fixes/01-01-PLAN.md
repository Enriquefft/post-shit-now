---
phase: 01-critical-setup-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/setup-db.ts
  - drizzle/migrations/0000_setup_rls_role.sql
  - drizzle/meta/_journal.json
autonomous: true
requirements: [C2, C3]

must_haves:
  truths:
    - "hub_user role exists in Neon database before migrations run"
    - "Database migrations complete without RLS policy errors"
    - "All tables including api_keys are created successfully"
    - "Setup wizard can run to completion on Neon"
  artifacts:
    - path: "drizzle/migrations/0000_setup_rls_role.sql"
      provides: "RLS role creation before schema migration"
      min_lines: 20
    - path: "drizzle/migrations/0001_schema.sql"
      provides: "Schema with RLS policies referencing hub_user"
      contains: "pgPolicy"
    - path: "drizzle/meta/_journal.json"
      provides: "Migration tracking meta file"
      min_lines: 10
  key_links:
    - from: "src/cli/setup-db.ts"
      to: "drizzle/migrations"
      via: "runMigrations() function"
      pattern: "runMigrations"
    - from: "drizzle/migrations/0000_setup_rls_role.sql"
      to: "drizzle/migrations/0001_schema.sql"
      via: "Migration ordering (0000 before 0001)"
      pattern: "0000_.*\\.sql"
---

<objective>
Fix database migration RLS policy error by creating hub_user role before schema migration. This resolves C2 (RLS policy error) and C3 (provider keys table missing), enabling database setup to complete successfully on Neon.

Purpose: The schema defines `pgRole("hub_user").existing()` but the role doesn't exist in Neon, causing migration failures. By creating the role in a pre-migration step, RLS policies can be applied correctly.

Output: Migration file 0000_setup_rls_role.sql that creates hub_user role, updated meta journal, successful migration execution.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-setup-fixes/01-CONTEXT.md
@.planning/phases/01-critical-setup-fixes/01-RESEARCH.md
@src/core/db/schema.ts
@src/cli/setup-db.ts
@src/core/db/migrate.ts

# Reference RLS pattern from research
@.planning/research/neon-drizzle-patterns.md
</context>

<tasks>

<task type="auto">
  <name>Create RLS role migration file (0000_setup_rls_role.sql)</name>
  <files>drizzle/migrations/0000_setup_rls_role.sql</files>
  <action>
Create drizzle/migrations/0000_setup_rls_role.sql with SQL to create hub_user role and grant permissions:

```sql
-- Create hub_user role for RLS policies
-- This must run BEFORE schema migration (0001_*.sql) which references hub_user

DO $$
BEGIN
  -- Check if role exists to avoid duplicate error
  IF NOT EXISTS (
    SELECT 1 FROM pg_roles WHERE rolname = 'hub_user'
  ) THEN
    -- Create the role
    CREATE ROLE hub_user;

    -- Grant schema usage
    GRANT USAGE ON SCHEMA public TO hub_user;

    -- Grant permissions on all existing tables
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO hub_user;

    -- Grant permissions on all existing sequences
    GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO hub_user;

    -- Ensure future tables inherit permissions
    ALTER DEFAULT PRIVILEGES IN SCHEMA public
      GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO hub_user;

    ALTER DEFAULT PRIVILEGES IN SCHEMA public
      GRANT USAGE, SELECT ON SEQUENCES TO hub_user;

    RAISE NOTICE 'Created hub_user role with appropriate permissions';
  ELSE
    RAISE NOTICE 'hub_user role already exists';
  END IF;
END $$;
```

This follows the CONTEXT.md decision: "Apply RLS to all tables or fail entirely" and the research pattern for role creation before schema migration.
</action>
  <verify>
Run: `head -50 drizzle/migrations/0000_setup_rls_role.sql` to verify file exists and contains role creation SQL.
</verify>
  <done>
File drizzle/migrations/0000_setup_rls_role.sql exists with SQL that creates hub_user role and grants permissions.
</done>
</task>

<task type="auto">
  <name>Update Drizzle meta journal for new migration</name>
  <files>drizzle/meta/_journal.json</files>
  <action>
Read drizzle/meta/_journal.json to understand current migration structure. Add entry for 0000_setup_rls_role.sql to the migrations array with appropriate timestamp and version. Ensure the journal reflects the correct order (0000 before 0001).

If _journal.json doesn't exist or is malformed, create a minimal valid structure:
```json
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "0000_setup_rls_role",
      "when": 1737393600000,
      "tag": "0000_setup_rls_role",
      "breakpoints": true
    }
  ]
}
```

Then ensure the existing 0001_schema migration has idx: 1, and increment all subsequent migration indices by 1.
</action>
  <verify>
Run: `cat drizzle/meta/_journal.json | jq .` to verify JSON is valid and 0000_setup_rls_role is first entry.
</verify>
  <done>
drizzle/meta/_journal.json is valid JSON with 0000_setup_rls_role as the first migration entry.
</done>
</task>

<task type="auto">
  <name>Test migration execution with new role setup</name>
  <files>src/cli/setup-db.ts</files>
  <action>
Verify setup-db.ts uses runMigrations() correctly and will execute migrations in order. No changes needed to setup-db.ts - the migration runner already handles sequential execution.

Create a test script at drizzle/migrations/test-role-migration.ts:
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { migrate } from 'drizzle-orm/neon-http/migrator';
import * as schema from '../../src/core/db/schema.ts';

// Test with a temporary database connection string
// In production, setup-db.ts handles this
const testUrl = process.env.TEST_DATABASE_URL || 'postgresql://test';
const db = drizzle(testUrl, { schema });

console.log('Testing migration with role setup...');
await migrate(db, { migrationsFolder: './drizzle/migrations' });
console.log('Migration test complete');
```

This verifies that the role is created before schema migrations reference it.
</action>
  <verify>
Run: `ls drizzle/migrations/0000_setup_rls_role.sql` to confirm migration file exists. Run: `jq .entries[0].version drizzle/meta/_journal.json` to confirm 0000_setup_rls_role is first.
</verify>
  <done>
Migration files exist in correct order, meta journal updated, ready for execution by setup-db.ts.
</done>
</task>

</tasks>

<verification>
After completing all tasks, verify:
1. drizzle/migrations/0000_setup_rls_role.sql exists and creates hub_user role
2. drizzle/meta/_journal.json has 0000_setup_rls_role as first migration
3. Migration files are in correct order (0000, 0001, etc.)
4. Setup-db.ts will execute migrations sequentially via runMigrations()
5. No changes needed to schema.ts - RLS policies can now reference existing role
</verification>

<success_criteria>
- hub_user role is created in migration before schema migration
- Migration journal reflects correct ordering (0000 before 0001)
- Database migrations complete without "role 'hub_user' does not exist" error
- api_keys table and all other tables are created successfully
- Setup wizard database step completes on Neon
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-setup-fixes/01-01-SUMMARY.md`
</output>
