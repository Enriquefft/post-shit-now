---
phase: 03-voice-profiling-and-content-generation
plan: 04
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/voice/interview.ts
  - src/voice/import.ts
  - src/cli/voice-interview.ts
autonomous: true
requirements:
  - VOICE-01
  - VOICE-02
  - VOICE-05
  - VOICE-06
  - VOICE-10

must_haves:
  truths:
    - "User can complete an adaptive voice profiling interview that branches based on answers"
    - "Interview adapts to user's experience level (spectrum-aware, not binary)"
    - "Blank-slate users get a shorter personality-first interview with starter archetypes"
    - "Bilingual users complete interview in both English and Spanish with language-specific sections"
    - "User can import existing content from X history, blog URLs, and raw text to bootstrap voice"
    - "User can trigger full voice recalibration via the interview CLI"
    - "Interview outputs a valid personal.yaml voice profile"
  artifacts:
    - path: "src/voice/interview.ts"
      provides: "Adaptive interview engine with branching logic, spectrum detection, bilingual support"
      exports: ["InterviewEngine", "InterviewState", "generateQuestions", "processAnswer", "finalizeProfile"]
    - path: "src/voice/import.ts"
      provides: "Content import from X history, blog scraping, raw text"
      exports: ["importXHistory", "importBlogContent", "importRawText", "analyzeImportedContent"]
    - path: "src/cli/voice-interview.ts"
      provides: "CLI entry point for voice interview and recalibration"
  key_links:
    - from: "src/voice/interview.ts"
      to: "src/voice/profile.ts"
      via: "Saves completed interview as voice profile"
      pattern: "saveProfile"
    - from: "src/voice/import.ts"
      to: "src/platforms/x/client.ts"
      via: "X API for importing post history"
      pattern: "XClient|x/client"
---

<objective>
Build the adaptive voice profiling interview engine and content import system.

Purpose: The voice interview is the primary onboarding experience. It captures the user's identity, communication style, content pillars, and boundaries. Content import provides an alternative/complementary path to bootstrap voice patterns from existing content.

Output: Interview engine with adaptive branching, spectrum-aware depth, bilingual support, content import from 3 sources, and CLI entry point.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-profiling-and-content-generation/03-RESEARCH.md
@.planning/phases/03-voice-profiling-and-content-generation/03-CONTEXT.md
@.planning/phases/03-voice-profiling-and-content-generation/03-01-SUMMARY.md
@src/voice/types.ts
@src/voice/profile.ts
@src/platforms/x/client.ts
@src/core/utils/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Adaptive interview engine</name>
  <files>src/voice/interview.ts</files>
  <action>
Create the adaptive voice profiling interview engine. This is NOT an interactive CLI that Claude runs — it's a **data model and logic library** that the `/psn:setup voice` slash command (Claude) uses to drive the interview conversationally.

**InterviewState type:**
```typescript
interface InterviewState {
  phase: "identity" | "style" | "platforms" | "language" | "review";
  questionIndex: number;
  answers: Map<string, string>;
  detectedExperience: "beginner" | "intermediate" | "advanced" | null;
  languages: ("en" | "es")[];
  importedContent: ImportedContent[] | null;
  isBlankSlate: boolean;
  isRecalibration: boolean;
  existingProfile?: VoiceProfile;
}
```

**Core functions:**

1. `createInterviewState(options?: { recalibration?: boolean; existingProfile?: VoiceProfile; importedContent?: ImportedContent[] }): InterviewState` — Initialize state. If recalibration, preserve existing calibration data. If importedContent provided, set `isBlankSlate = false` and pre-detect experience level.

2. `generateQuestions(state: InterviewState): InterviewQuestion[]` — Generate next batch of questions based on current phase and detected experience:

   **Identity phase (core, 5-8 questions):**
   - Content pillars: "What 3-5 topics do you want to be known for?"
   - Boundaries: "Are there topics or tones you want to avoid?"
   - Reference voices: "Who do you admire on social media? What about their style appeals to you?"
   - Audience: "Who are you trying to reach?"
   - Goals: "What does success look like for your social media presence?"

   **For blank-slate users** (no imported content, detected beginner):
   - Shorter identity phase (3-5 questions)
   - Offer starter archetypes: "Thought Leader", "Educator", "Storyteller", "Curator", "Provocateur"
   - User picks 1-2 archetypes as starting templates

   **Style phase (branching based on experience):**
   - Beginners: "How formal do you want to sound? (1=very casual, 10=very formal)"
   - Advanced: "Describe your writing style in 2-3 sentences" + extract style traits

   **Platform phase:**
   - For each enabled platform: "How do you want to show up on [platform]? Any different from your default?"

   **Language phase (if bilingual):**
   - "Do you post in both English and Spanish?"
   - If yes: per-language vocabulary, expressions, tone adjustments

3. `processAnswer(state: InterviewState, questionId: string, answer: string): InterviewState` — Update state with answer. Detect experience level from answer patterns (mentions metrics, tools, strategies = advanced; simple/uncertain answers = beginner). Branch to appropriate next questions. Return updated state.

4. `detectExperienceLevel(answers: Map<string, string>, importedContent?: ImportedContent[]): "beginner" | "intermediate" | "advanced"` — Analyze answers and imported content quantity/quality to determine spectrum position.

5. `finalizeProfile(state: InterviewState): VoiceProfile` — Convert completed interview state into a VoiceProfile. Map answers to schema fields. Set calibration status based on whether content was imported. Return valid profile (validated with Zod before return).

**InterviewQuestion type:**
```typescript
interface InterviewQuestion {
  id: string;
  phase: InterviewState["phase"];
  text: string;
  hint?: string;  // Helper text for the user
  type: "open" | "scale" | "choice" | "multi-choice";
  options?: string[];  // For choice/multi-choice
  required: boolean;
  branchCondition?: string;  // When to show this question
}
```

**Important design notes:**
- The interview engine provides the STRUCTURE (questions, branching logic, state management)
- Claude drives the CONVERSATION (asks questions naturally, interprets responses, decides when to branch)
- The engine is a library, not a CLI program — Claude calls these functions from the slash command
- Questions should feel like a conversation with a social media strategist, not a form (per CONTEXT.md specifics)
  </action>
  <verify>Run `bun run typecheck` — no errors. Run `bun run lint` — passes.</verify>
  <done>Interview engine provides structured questions with adaptive branching based on experience level, bilingual support, blank-slate archetype path, and produces valid VoiceProfile from completed state.</done>
</task>

<task type="auto">
  <name>Task 2: Content import and analysis</name>
  <files>src/voice/import.ts, src/cli/voice-interview.ts</files>
  <action>
**src/voice/import.ts** — Content import from multiple sources:

**ImportedContent type:**
```typescript
interface ImportedContent {
  text: string;
  platform: string;
  source: "x-history" | "blog" | "raw-text" | "other";
  engagementSignals?: { likes?: number; retweets?: number; replies?: number; views?: number };
  createdAt?: string;
}

interface ContentAnalysis {
  sampleCount: number;
  avgLength: number;
  detectedTone: string;
  commonPatterns: string[];
  vocabularyFingerprint: string[];
  sentencePatterns: string[];
  topicClusters: string[];
}
```

1. `importXHistory(accessToken: string): Promise<ImportedContent[]>` — Use X API v2: GET `/2/users/me` to get user ID, then GET `/2/users/{id}/tweets?max_results=100&tweet.fields=created_at,public_metrics,text&exclude=retweets,replies`. Paginate if needed (up to 3 pages = 300 tweets). Filter for original content only (skip tweets that start with "@" — those are replies). Map to ImportedContent with engagement signals.

   Follow existing XClient patterns from `src/platforms/x/client.ts` — use raw fetch with Bearer token auth. Handle rate limits gracefully (X timelines: 15 requests per 15 minutes for per-user auth).

2. `importBlogContent(urls: string[]): Promise<ImportedContent[]>` — For each URL, fetch HTML content. Extract text content by stripping HTML tags (simple regex-based: remove `<script>`, `<style>`, then strip remaining tags). Split into meaningful paragraphs. Return as ImportedContent with source "blog". Limit to 50 content chunks per URL. Handle fetch errors gracefully (skip failed URLs, report which ones failed).

3. `importRawText(texts: string[]): Promise<ImportedContent[]>` — Accept array of raw text samples. Split each by paragraphs. Return as ImportedContent with source "raw-text".

4. `analyzeImportedContent(content: ImportedContent[]): ContentAnalysis` — Analyze imported content to extract voice patterns:
   - Count samples, compute average length
   - Detect dominant tone (formal/casual based on vocabulary analysis — presence of contractions, slang, technical jargon)
   - Find common opening patterns (questions, statements, hooks)
   - Extract vocabulary fingerprint (most frequently used non-common words)
   - Identify sentence patterns (avg sentence length, question frequency, exclamation frequency)
   - Cluster topics by keyword co-occurrence

   This is a heuristic analysis — not ML. Use simple string processing. The analysis feeds into the interview engine to pre-populate style traits and skip questions the content already answers.

**src/cli/voice-interview.ts** — CLI entry point:
- Export functions for use by the `/psn:setup voice` slash command
- `startInterview(options?: { recalibration?: boolean }): Promise<{ state: InterviewState; questions: InterviewQuestion[] }>` — Initialize and return first batch of questions
- `submitAnswers(state: InterviewState, answers: Record<string, string>): Promise<{ state: InterviewState; questions: InterviewQuestion[]; complete: boolean }>` — Process answers, return next questions or signal completion
- `completeInterview(state: InterviewState): Promise<{ profile: VoiceProfile; profilePath: string; strategyPath?: string }>` — Finalize profile, save to disk, optionally generate strategy.yaml
- `importContent(sources: { xHistory?: boolean; blogUrls?: string[]; rawTexts?: string[] }): Promise<{ imported: ImportedContent[]; analysis: ContentAnalysis }>` — Run imports and analysis
- Standard CLI `import.meta.main` block with JSON output pattern

Import loadHubEnv for access tokens. Import interview engine. Import profile save/generate functions.
  </action>
  <verify>Run `bun run typecheck` — no errors. Run `bun run lint` — passes.</verify>
  <done>Content can be imported from X history (via OAuth), blogs (via URL scraping), and raw text. Imported content is analyzed for voice patterns. CLI provides structured interface for slash command to drive the interview.</done>
</task>

</tasks>

<verification>
- `bun run typecheck` passes
- `bun run lint` passes
- Interview engine generates questions for all phases (identity, style, platforms, language)
- Blank-slate path offers archetype selection with shorter interview
- Content import handles X API, blog URLs, and raw text
- analyzeImportedContent produces meaningful ContentAnalysis
- finalizeProfile produces Zod-valid VoiceProfile
</verification>

<success_criteria>
- VOICE-01: Adaptive interview captures identity, voice patterns, boundaries, platform preferences
- VOICE-02: Import from X history (OAuth), blog URLs, and raw text
- VOICE-05: Blank-slate users get shorter personality-first interview with archetypes
- VOICE-06: Bilingual interview with language-specific voice sections
- VOICE-10: Recalibration mode re-runs interview preserving calibration data
- Interview feels like a conversation, not a form (structured data + Claude's natural language)
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-profiling-and-content-generation/03-04-SUMMARY.md`
</output>
