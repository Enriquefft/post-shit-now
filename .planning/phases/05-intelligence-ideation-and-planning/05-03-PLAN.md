---
phase: 05-intelligence-ideation-and-planning
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ideas/types.ts
  - src/ideas/capture.ts
  - src/ideas/lifecycle.ts
  - src/ideas/bank.ts
  - src/cli/capture.ts
  - .claude/commands/psn/capture.md
  - src/learning/preference-model.ts
autonomous: true
requirements:
  - IDEA-01
  - IDEA-02
  - IDEA-03
  - IDEA-04
  - IDEA-06
  - IDEA-07
  - IDEA-08

must_haves:
  truths:
    - "User can capture an idea with a sentence and optional inline tags in under 30 seconds"
    - "Ideas flow through the maturity pipeline: spark -> seed -> ready -> claimed -> developed -> used/killed"
    - "Ideas have urgency classification: timely (24-48h), seasonal, evergreen"
    - "Timely ideas auto-expire and get flagged for killing"
    - "Killed ideas record reasoning and feed back into preference model via computeWeeklyUpdate"
    - "Team members can claim company ideas (ready -> claimed with userId lock)"
    - "/psn:capture distinguishes timely vs evergreen via inline tags or inference"
  artifacts:
    - path: "src/ideas/types.ts"
      provides: "IdeaStatus, Urgency, Idea types, valid transitions map"
    - path: "src/ideas/capture.ts"
      provides: "captureIdea function with inline tag parsing"
      exports: ["captureIdea", "parseInlineTags"]
    - path: "src/ideas/lifecycle.ts"
      provides: "Status transitions, auto-promote, staleness detection, expiry"
      exports: ["transitionIdea", "autoPromoteIdeas", "getStaleIdeas", "expireTimelyIdeas"]
    - path: "src/ideas/bank.ts"
      provides: "Query, filter, search ideas from DB"
      exports: ["getReadyIdeas", "searchIdeas", "getIdeasByStatus"]
    - path: "src/cli/capture.ts"
      provides: "CLI entry point for /psn:capture"
    - path: ".claude/commands/psn/capture.md"
      provides: "Slash command definition for idea capture"
    - path: "src/learning/preference-model.ts"
      provides: "Updated computeWeeklyUpdate that queries killed ideas for feedback"
  key_links:
    - from: "src/ideas/capture.ts"
      to: "src/core/db/schema.ts"
      via: "insert into ideas table"
      pattern: "db\\.insert.*ideas"
    - from: "src/ideas/lifecycle.ts"
      to: "src/ideas/types.ts"
      via: "VALID_TRANSITIONS map for state machine"
      pattern: "VALID_TRANSITIONS"
    - from: "src/cli/capture.ts"
      to: "src/ideas/capture.ts"
      via: "CLI calls captureIdea"
      pattern: "captureIdea"
    - from: "src/learning/preference-model.ts"
      to: "src/core/db/schema.ts"
      via: "query killed ideas for preference feedback"
      pattern: "ideas.*killed|killReason"
---

<objective>
Build the idea bank: type definitions, capture with inline tag parsing, maturity pipeline state machine, staleness/expiry management, querying, and the /psn:capture slash command. Wire killed idea feedback into the preference model.

Purpose: Ideas are the raw material for weekly planning. Without an idea bank, the system has no memory of content opportunities between sessions. Killed ideas inform the preference model about what types of content the user rejects.
Output: Complete src/ideas/ directory with types, capture, lifecycle, and bank modules. CLI script and slash command for /psn:capture. Updated preference model with killed-idea feedback loop.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/cli/post.ts
@.claude/commands/psn/post.md
@src/learning/preference-model.ts
@.planning/phases/05-intelligence-ideation-and-planning/05-CONTEXT.md
@.planning/phases/05-intelligence-ideation-and-planning/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idea types, capture logic, and lifecycle state machine</name>
  <files>
    src/ideas/types.ts
    src/ideas/capture.ts
    src/ideas/lifecycle.ts
  </files>
  <action>
**src/ideas/types.ts:**
- `IdeaStatus` type: "spark" | "seed" | "ready" | "claimed" | "developed" | "used" | "killed"
- `Urgency` type: "timely" | "seasonal" | "evergreen"
- `IdeaSourceType` type: "trend" | "capture" | "plan" | "remix" | "recycle"
- `Idea` interface matching the ideas table schema from schema.ts
- `CaptureInput` interface: { text, tags?, urgency?, hub?, pillar?, platform?, format? }
- `VALID_TRANSITIONS` constant: Record<IdeaStatus, IdeaStatus[]> as defined in RESEARCH.md:
  - spark: [seed, killed]
  - seed: [ready, killed, spark]
  - ready: [claimed, killed, seed]
  - claimed: [developed, ready]
  - developed: [used, killed, claimed]
  - used: [] (terminal)
  - killed: [spark] (can resurrect)
- `STALENESS_DAYS` constant: { spark: 14, seed: 30 } (per RESEARCH.md recommendation)

**src/ideas/capture.ts:**
- `parseInlineTags(input: string)`: Extract #key:value tags from input text. Returns { text: string (cleaned), tags: Record<string, string> }. Pattern: `/#(\w+):(\S+)/g`. Recognized tag keys: pillar, platform, format, urgency, hub.
- `captureIdea(db, userId, input: CaptureInput)`: Insert into ideas table. If urgency is "timely" and no expiresAt, set expiresAt to 48 hours from now. If urgency is "seasonal" and no expiresAt, set expiresAt to 30 days. Map parsed tags to the appropriate columns (pillar, platform, format). Set sourceType to "capture". Returns the created idea with its id.
- `inferUrgency(text: string)`: Simple heuristic -- if text contains time-sensitive keywords ("breaking", "just announced", "today", "this week", "trending now"), return "timely". If contains seasonal terms ("holiday", "new year", "black friday", "q4"), return "seasonal". Otherwise "evergreen". Used when urgency is not explicitly provided.

**src/ideas/lifecycle.ts:**
- `transitionIdea(db, ideaId, newStatus, opts?: { claimedBy?, killReason? })`: Validates transition against VALID_TRANSITIONS. If invalid, throws error with current + attempted status. Updates status, lastTouchedAt. If newStatus === "claimed", set claimedBy. If newStatus === "killed", set killReason (required). Returns updated idea.
- `autoPromoteIdeas(db, userId)`: Queries spark ideas that have matching trends (by title keyword overlap against trends table where overallScore > 50). Promotes matching sparks to seed. Also promotes seeds that have notes added (notes is not null) to ready. Returns count of promoted ideas. Per user decision: auto-promote with override.
- `getStaleIdeas(db, userId)`: Queries ideas where status is spark and lastTouchedAt is older than STALENESS_DAYS.spark, or status is seed and lastTouchedAt is older than STALENESS_DAYS.seed. Returns stale ideas for user review.
- `expireTimelyIdeas(db, userId)`: Queries timely ideas where expiresAt is in the past and status is not used/killed. Sets status to "killed" with killReason "expired (timely)". Returns count of expired ideas.
- `recordKillFeedback(db, ideaId, killReason: string)`: Updates kill_reason on the idea. This data is queried by computeWeeklyUpdate in preference-model.ts to understand what types of ideas the user rejects (see Task 2 for the wiring).
  </action>
  <verify>Run `bun run check` to confirm all files compile. Grep for VALID_TRANSITIONS, captureIdea, transitionIdea, autoPromoteIdeas exports.</verify>
  <done>Idea types defined, capture function parses inline tags and inserts to DB, lifecycle state machine validates all transitions, staleness/expiry detection works.</done>
</task>

<task type="auto">
  <name>Task 2: Create idea bank queries, capture CLI, /psn:capture, and wire killed-idea feedback into preference model</name>
  <files>
    src/ideas/bank.ts
    src/cli/capture.ts
    .claude/commands/psn/capture.md
    src/learning/preference-model.ts
  </files>
  <action>
**src/ideas/bank.ts:**
- `getReadyIdeas(db, userId, opts?: { pillar?, platform?, limit? })`: Query ideas with status "ready", ordered by lastTouchedAt desc. Filter by pillar/platform if provided. Default limit 10.
- `searchIdeas(db, userId, query: string, opts?: { status?, limit? })`: Search ideas by ILIKE on title and notes columns. Optional status filter. Default limit 20.
- `getIdeasByStatus(db, userId, status: IdeaStatus, opts?: { limit? })`: Simple status filter query.
- `getIdeaStats(db, userId)`: Returns count by status: { spark: N, seed: N, ready: N, claimed: N, developed: N, used: N, killed: N }.
- `listIdeas(db, userId, opts?: { status?, urgency?, pillar?, limit?, offset? })`: General-purpose list with optional filters and pagination. Returns ideas ordered by createdAt desc.
- `getKilledIdeasSince(db, userId, since: Date)`: Query ideas with status "killed" and lastTouchedAt > since. Returns ideas with their killReason and pillar. Used by preference model to learn from rejections.

**src/cli/capture.ts:**
Follow the established CLI pattern from src/cli/post.ts:
- Export functions for import AND have import.meta.main entry point
- Accept argv: `capture "idea text with #tags"`, `list [--status=ready] [--pillar=ai]`, `stats`, `stale`, `expire`
- `capture` subcommand: Parse inline tags from text, call captureIdea, output JSON with created idea
- `list` subcommand: Call listIdeas with parsed filters, output JSON array
- `stats` subcommand: Call getIdeaStats, output JSON
- `stale` subcommand: Call getStaleIdeas, output JSON array
- `expire` subcommand: Call expireTimelyIdeas, output JSON with count
- All output to stdout as JSON (Claude interprets it per established pattern)
- Load DATABASE_URL from config/hub.env via loadEnvFile

**.claude/commands/psn/capture.md:**
Slash command that instructs Claude to:
1. Accept user's idea (any format: sentence, URL, screenshot description, raw thought)
2. Run the capture CLI: `bun run src/cli/capture.ts capture "user's idea text #optional:tags"`
3. Parse the JSON output and confirm the idea was captured
4. Show the idea's status, urgency, and any inferred tags
5. Ask if the user wants to add notes, change urgency, or capture another
6. For `list` mode: run `bun run src/cli/capture.ts list` and present ideas in a readable format
7. For `stale` mode: show stale ideas and ask user to keep or kill each one

The slash command should be concise and fast -- the goal is under 30 seconds for a basic capture (IDEA-01).

**Wire killed-idea feedback into src/learning/preference-model.ts (IDEA-08):**
Extend the existing `computeWeeklyUpdate` function to query killed ideas:
- Import `getKilledIdeasSince` from src/ideas/bank.ts
- After the existing edit pattern analysis section, add a new section for killed-idea feedback:
  - Call `getKilledIdeasSince(db, userId, sevenDaysAgo)` to get recently killed ideas
  - Group killed ideas by pillar to identify which pillars the user is rejecting ideas from
  - Group killed ideas by killReason to identify common rejection patterns (e.g., "not relevant", "too generic", "expired (timely)")
  - Store the aggregated rejection signals in the preference model's `killedIdeaPatterns` field (add this field to the model -- jsonb column stores: { rejectedPillars: Record<string, number>, commonReasons: string[], recentKills: number })
  - These signals inform future ideation: pillars with high kill rates get down-weighted in idea generation, recurring kill reasons are surfaced as warnings
- Update the `WeeklyUpdateSummary` interface to include `killedIdeasProcessed: number`
- Gracefully handle case where ideas table doesn't exist yet (try/catch returning 0 kills)
  </action>
  <verify>Run `bun run check` to confirm all files compile. Verify .claude/commands/psn/capture.md exists. Grep for getReadyIdeas, listIdeas, getKilledIdeasSince exports in bank.ts. Grep for "killedIdea" in preference-model.ts to confirm the feedback loop is wired.</verify>
  <done>Idea bank queries work for ready ideas, search, filtering, and killed-idea retrieval. CLI supports capture/list/stats/stale/expire subcommands. /psn:capture slash command enables fast idea capture. Preference model's computeWeeklyUpdate queries killed ideas to learn from rejections and inform future ideation.</done>
</task>

</tasks>

<verification>
- `bun run check` passes
- src/ideas/ directory has types.ts, capture.ts, lifecycle.ts, bank.ts
- src/cli/capture.ts has import.meta.main entry point
- .claude/commands/psn/capture.md exists
- State machine prevents invalid transitions (e.g., spark -> developed should fail)
- Inline tag parsing extracts #pillar:ai #format:thread correctly
- src/learning/preference-model.ts computeWeeklyUpdate queries killed ideas
- getKilledIdeasSince export exists in bank.ts
</verification>

<success_criteria>
Complete idea bank system where ideas can be captured with inline tags, flow through the maturity pipeline, get staleness warnings, and expire when timely. CLI and slash command provide fast capture UX. Killed ideas feed back into the preference model so the system learns what the user rejects.
</success_criteria>

<output>
After completion, create `.planning/phases/05-intelligence-ideation-and-planning/05-03-SUMMARY.md`
</output>
