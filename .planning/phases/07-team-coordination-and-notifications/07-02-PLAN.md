---
phase: 07-team-coordination-and-notifications
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/team/hub.ts
  - src/team/invite.ts
  - src/team/members.ts
  - src/cli/setup-company-hub.ts
  - src/cli/setup-join.ts
  - src/cli/setup-disconnect.ts
  - src/cli/setup.ts
  - .gitignore
autonomous: true
requirements: [TEAM-01, TEAM-02, TEAM-03, TEAM-07, CONFIG-05, CONFIG-06]
user_setup:
  - service: neon
    why: "Neon Postgres for Company Hub database provisioning"
    env_vars:
      - name: NEON_API_KEY
        source: "Already configured in Phase 1 setup"
  - service: trigger-dev
    why: "Trigger.dev project for Company Hub task scheduling"
    env_vars:
      - name: TRIGGER_SECRET_KEY
        source: "Already configured in Phase 1 setup"

must_haves:
  truths:
    - "Admin can create a Company Hub via CLI, provisioning a new Neon DB and generating admin team_members record"
    - "Admin can generate one-time invite codes with 48-hour expiry stored in invite_codes table"
    - "Team member can join a Company Hub using an invite code, creating a connection file in .hubs/"
    - "Team member leaving cleanly deletes connection file and marks leftAt in team_members"
    - ".hubs/ directory is gitignored to protect connection credentials"
  artifacts:
    - path: "src/team/hub.ts"
      provides: "Company Hub provisioning, connection file management, hub discovery"
      exports: ["createCompanyHub", "discoverCompanyHubs", "getHubConnection", "removeHubConnection"]
    - path: "src/team/invite.ts"
      provides: "Invite code generation and redemption"
      exports: ["generateInviteCode", "redeemInviteCode", "listPendingInvites"]
    - path: "src/team/members.ts"
      provides: "Team member CRUD operations, role management"
      exports: ["addTeamMember", "removeTeamMember", "promoteToAdmin", "listTeamMembers", "getTeamMember"]
    - path: "src/cli/setup-company-hub.ts"
      provides: "CLI flow for Company Hub creation"
      exports: ["setupCompanyHub"]
    - path: "src/cli/setup-join.ts"
      provides: "CLI flow for joining a Company Hub with invite code"
      exports: ["setupJoinHub"]
    - path: "src/cli/setup-disconnect.ts"
      provides: "CLI flow for disconnecting from a Company Hub"
      exports: ["setupDisconnect"]
  key_links:
    - from: "src/team/hub.ts"
      to: "src/core/db/connection.ts"
      via: "createHubConnection for Company Hub DB"
      pattern: "createHubConnection"
    - from: "src/team/invite.ts"
      to: "src/core/db/schema.ts"
      via: "inviteCodes table operations"
      pattern: "inviteCodes"
    - from: "src/cli/setup.ts"
      to: "src/cli/setup-company-hub.ts"
      via: "hub subcommand routing"
      pattern: "setup.*hub|setup.*join|setup.*disconnect"
---

<objective>
Build Company Hub provisioning, invite code flow, and team member management. Users can create Company Hubs, generate invite codes, join hubs, and disconnect cleanly.

Purpose: Establish the multi-tenant team infrastructure that the approval workflow and notification system will build on.
Output: Hub creation CLI, invite code generation/redemption, team member CRUD, connection file management.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-team-coordination-and-notifications/07-RESEARCH.md
@.planning/phases/07-team-coordination-and-notifications/07-CONTEXT.md
@.planning/phases/07-team-coordination-and-notifications/07-01-PLAN.md

# Existing setup flow (pattern to extend)
@src/cli/setup.ts
@src/cli/setup-x-oauth.ts
@src/core/db/connection.ts
@src/core/db/schema.ts
@src/core/types/index.ts
@src/team/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Company Hub provisioning and connection file management</name>
  <files>
    src/team/hub.ts
    .gitignore
  </files>
  <action>
    Create `src/team/hub.ts`:

    `createCompanyHub(params: { slug: string; displayName: string; adminUserId: string; encryptionKey: string })`:
    - Generate a hub ID: `hub_${crypto.randomUUID().slice(0, 12)}`
    - Call neonctl to create a new Neon database (same pattern as Personal Hub setup in setup.ts):
      `neonctl databases create --name psn-company-${slug} --project-id ${neonProjectId}`
    - Get the connection string from neonctl output
    - Run Drizzle migrations on the new Company Hub DB (using the same migration runner from core/db/migrate.ts)
    - Insert creator as admin in team_members table
    - Create connection file at `.hubs/company-${slug}.json` with HubConnection structure
    - Return the HubConnection object

    `discoverCompanyHubs(projectRoot: string): Promise<HubConnection[]>`:
    - Scan `.hubs/` directory for `company-*.json` files
    - Parse each with HubConnectionSchema Zod validation
    - Return array of validated connections
    - Return empty array if .hubs/ doesn't exist (graceful degradation)

    `getHubConnection(projectRoot: string, slugOrId: string): Promise<HubConnection | null>`:
    - Find a specific hub connection by slug or hubId
    - Returns null if not found

    `removeHubConnection(projectRoot: string, slug: string): Promise<void>`:
    - Delete `.hubs/company-${slug}.json` file
    - Does NOT delete the Neon DB or team_members record (content preserved per CONTEXT.md)

    `getHubDb(connection: HubConnection)`:
    - Create a Drizzle database connection to the Company Hub
    - Use the same createHubConnection pattern from core/db/connection.ts
    - Return typed Drizzle client

    Update `.gitignore`:
    - Add `.hubs/` entry to ensure connection files are never committed
    - Add comment: `# Company Hub connection files (contain credentials)`
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit` to verify hub.ts compiles. Check .gitignore includes `.hubs/` entry.
  </verify>
  <done>
    Company Hub provisioning creates Neon DB, runs migrations, writes connection file. Hub discovery scans .hubs/ directory. Connection management supports add/find/remove.
  </done>
</task>

<task type="auto">
  <name>Task 2: Invite code generation and redemption</name>
  <files>
    src/team/invite.ts
  </files>
  <action>
    Create `src/team/invite.ts`:

    `generateInviteCode(db, params: { hubId: string; createdBy: string; expiryHours?: number }): Promise<string>`:
    - Generate code: `crypto.randomBytes(16).toString('hex')` (32 chars, cryptographically secure)
    - Default expiryHours = 48 (per CONTEXT.md: one-time use, 48h expiry)
    - Insert into invite_codes table: { hubId, code, createdBy, expiresAt: new Date(Date.now() + expiryHours * 3600000) }
    - Return the generated code string

    `redeemInviteCode(db, params: { code: string; userId: string }): Promise<{ hubId: string; success: boolean; error?: string }>`:
    - Look up code in invite_codes table
    - Validate: code exists, usedBy is null (one-time use), expiresAt > now (not expired)
    - If invalid, return { success: false, error: 'Invalid or expired invite code' }
    - Use transaction:
      - Update invite_codes: set usedBy = userId, usedAt = now
      - Insert team_members: { userId, hubId, role: 'member' } (all invitees join as member)
    - Return { hubId, success: true }

    `listPendingInvites(db, hubId: string): Promise<Array<{ code: string; expiresAt: Date; createdBy: string }>>`:
    - Query invite_codes WHERE hubId = hubId AND usedBy IS NULL AND expiresAt > NOW()
    - Return pending (unused, unexpired) codes

    `cleanupExpiredInvites(db): Promise<number>`:
    - DELETE FROM invite_codes WHERE expiresAt < NOW() AND usedBy IS NULL
    - Return count of deleted codes (for logging)
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify invite code generation uses crypto.randomBytes (not Math.random).
  </verify>
  <done>
    Invite codes are cryptographically secure, one-time-use, 48h default expiry. Redemption validates and creates team_members record atomically. Cleanup removes expired unused codes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Team member management</name>
  <files>
    src/team/members.ts
  </files>
  <action>
    Create `src/team/members.ts`:

    `addTeamMember(db, params: { userId: string; hubId: string; role: HubRole; displayName?: string; email?: string }): Promise<TeamMember>`:
    - Insert into team_members table
    - Return the created TeamMember record
    - Throws if unique constraint (userId, hubId) violated (already a member)

    `removeTeamMember(db, params: { userId: string; hubId: string }): Promise<void>`:
    - UPDATE team_members SET leftAt = NOW() WHERE userId = userId AND hubId = hubId AND leftAt IS NULL
    - Soft delete — preserves record for attribution (CONTEXT.md: content stays with attribution)
    - Does NOT delete posts or analytics by this member

    `promoteToAdmin(db, params: { userId: string; hubId: string }): Promise<void>`:
    - UPDATE team_members SET role = 'admin' WHERE userId = userId AND hubId = hubId AND leftAt IS NULL
    - Throws if member not found or already left

    `demoteToMember(db, params: { userId: string; hubId: string }): Promise<void>`:
    - UPDATE team_members SET role = 'member' WHERE userId = userId AND hubId = hubId AND leftAt IS NULL
    - Guard: prevent demoting last admin (query count of admins first)

    `listTeamMembers(db, hubId: string): Promise<TeamMember[]>`:
    - SELECT * FROM team_members WHERE hubId = hubId AND leftAt IS NULL ORDER BY joinedAt
    - Returns only active members

    `getTeamMember(db, params: { userId: string; hubId: string }): Promise<TeamMember | null>`:
    - SELECT WHERE userId AND hubId AND leftAt IS NULL
    - Returns null if not found or left

    `isAdmin(db, params: { userId: string; hubId: string }): Promise<boolean>`:
    - Quick check: does an active team_member record exist with role = 'admin'?
    - Used as guard in approval workflow and invite code generation
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify removeTeamMember soft-deletes (sets leftAt) rather than hard-deleting.
  </verify>
  <done>
    Team member CRUD with soft-delete for offboarding. Role promotion/demotion with last-admin guard. isAdmin helper for authorization checks.
  </done>
</task>

<task type="auto">
  <name>Task 4: Setup CLI extensions for hub/join/disconnect</name>
  <files>
    src/cli/setup-company-hub.ts
    src/cli/setup-join.ts
    src/cli/setup-disconnect.ts
    src/cli/setup.ts
  </files>
  <action>
    Create `src/cli/setup-company-hub.ts`:
    - `setupCompanyHub(params: { slug: string; displayName: string })` — JSON output for Claude
    - Steps:
      1. Check NEON_API_KEY is set
      2. Call createCompanyHub() from team/hub.ts
      3. Run migrations on new Company Hub DB
      4. Set up Company Hub OAuth tokens (copy from Personal Hub or set up new ones)
      5. Return SetupResult with { hubId, slug, displayName, connectionFile }

    Create `src/cli/setup-join.ts`:
    - `setupJoinHub(params: { code: string })` — JSON output for Claude
    - Steps:
      1. Parse invite code
      2. Need to connect to the Company Hub DB to redeem — but we don't have the connection yet
      3. Solution: invite code redemption endpoint. The code contains enough info to identify the hub. The admin shares the code + hub URL (database URL is in the invite or resolved server-side)
      4. Alternative approach: invite code is a compound token: `{hubId}:{randomCode}` — the hubId portion is used to look up the Company Hub connection from a shared registry or the code itself encodes the connection endpoint
      5. Simplest approach matching project patterns: Admin generates code + shares connection details (slug, DB URL) as a single "invite bundle" JSON. Member saves it to .hubs/ and redeems the code. This avoids needing a central registry.
      6. `setupJoinHub({ inviteBundle: string })` where inviteBundle is base64-encoded JSON with { code, slug, displayName, databaseUrl, triggerProjectId, encryptionKey }
      7. Decode bundle, validate code against Company Hub DB, create team_members record, save connection file
      8. Return SetupResult with { hubId, slug, role: 'member' }

    Create `src/cli/setup-disconnect.ts`:
    - `setupDisconnect(params: { slug: string })` — JSON output for Claude
    - Steps:
      1. Find connection file in .hubs/
      2. Connect to Company Hub DB
      3. Call removeTeamMember() to soft-delete
      4. Call removeHubConnection() to delete local connection file
      5. Return SetupResult with { slug, disconnected: true }

    Update `src/cli/setup.ts`:
    - Import setupCompanyHub, setupJoinHub, setupDisconnect
    - Add subcommand routing:
      - `hub` subcommand -> setupCompanyHub
      - `join` subcommand -> setupJoinHub
      - `disconnect` subcommand -> setupDisconnect
    - Existing setup flow (personal hub) remains the default with no subcommand
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit` to verify all CLI files compile. Verify setup.ts routes subcommands correctly.
  </verify>
  <done>
    CLI supports: `/psn:setup hub` for Company Hub creation, `/psn:setup join` with invite bundle for joining, `/psn:setup disconnect` for clean departure. All output JSON for Claude interpretation.
  </done>
</task>

</tasks>

<verification>
- [ ] `pnpm exec tsc --noEmit` passes with all new team files
- [ ] createCompanyHub provisions Neon DB and writes connection file
- [ ] Invite codes use crypto.randomBytes (not Math.random)
- [ ] Invite redemption is transactional (atomic code + member record)
- [ ] removeTeamMember soft-deletes (leftAt) not hard-deletes
- [ ] demoteToMember prevents demoting last admin
- [ ] .gitignore includes `.hubs/` entry
- [ ] Setup subcommands (hub, join, disconnect) route correctly
- [ ] Connection files follow HubConnection schema validated by Zod
</verification>

<success_criteria>
- Admin can create a Company Hub and get a connection file
- Admin can generate invite codes with 48h expiry
- Members can join using invite bundle and get a connection file
- Members can disconnect cleanly (soft-delete + file removal)
- All team operations use the Company Hub DB, not Personal Hub
- .hubs/ is gitignored
</success_criteria>

<output>
After completion, create `.planning/phases/07-team-coordination-and-notifications/07-02-SUMMARY.md`
</output>
