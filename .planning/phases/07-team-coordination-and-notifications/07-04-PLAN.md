---
phase: 07-team-coordination-and-notifications
plan: 04
type: execute
wave: 4
depends_on: [07-01, 07-03]
files_modified:
  - src/notifications/provider.ts
  - src/notifications/waha.ts
  - src/notifications/twilio.ts
  - src/notifications/dispatcher.ts
  - src/notifications/commands.ts
  - src/notifications/digest.ts
  - src/trigger/notification-dispatcher.ts
  - src/trigger/digest-compiler.ts
autonomous: true
requirements: [NOTIF-01, NOTIF-02, NOTIF-03, NOTIF-04, NOTIF-05, NOTIF-06, NOTIF-07, NOTIF-08]

must_haves:
  truths:
    - "WhatsApp provider abstraction supports both WAHA and Twilio through the same interface"
    - "Push notifications dispatch immediately for approval requests, post failures, token expiry, and viral alerts"
    - "Digest compiler aggregates events and delivers at configurable time (daily/twice daily/weekly)"
    - "Structured commands parse WhatsApp button taps and text replies (approve, reject, R1/R2/R3)"
    - "Fatigue prevention enforces max 3 push/day, 2hr cooldown, 30min dedup, and quiet hours"
  artifacts:
    - path: "src/notifications/provider.ts"
      provides: "Provider factory that returns WAHA or Twilio implementation based on config"
      exports: ["createWhatsAppProvider", "WhatsAppProviderConfig"]
    - path: "src/notifications/waha.ts"
      provides: "WAHA REST API client implementing WhatsAppProvider interface"
      exports: ["WahaProvider"]
    - path: "src/notifications/twilio.ts"
      provides: "Twilio REST API client implementing WhatsAppProvider interface"
      exports: ["TwilioProvider"]
    - path: "src/notifications/dispatcher.ts"
      provides: "Notification dispatch engine with tier routing, fatigue prevention, quiet hours"
      exports: ["dispatchNotification", "checkFatigueLimits", "isQuietHours"]
    - path: "src/notifications/commands.ts"
      provides: "Incoming WhatsApp command parser and state machine"
      exports: ["parseIncomingCommand", "processCommand", "updateConversationState"]
    - path: "src/notifications/digest.ts"
      provides: "Digest compilation from notification events"
      exports: ["compileDigest", "formatDigestMessage"]
    - path: "src/trigger/notification-dispatcher.ts"
      provides: "Trigger.dev task for async notification dispatch"
      exports: ["notificationDispatcherTask"]
    - path: "src/trigger/digest-compiler.ts"
      provides: "Trigger.dev scheduled task for digest compilation and delivery"
      exports: ["digestCompilerTask"]
  key_links:
    - from: "src/notifications/dispatcher.ts"
      to: "src/notifications/provider.ts"
      via: "Provider factory for WAHA/Twilio"
      pattern: "createWhatsAppProvider"
    - from: "src/notifications/dispatcher.ts"
      to: "src/core/db/schema.ts"
      via: "notification_log and notification_preferences tables"
      pattern: "notificationLog.*notificationPreferences"
    - from: "src/trigger/notification-dispatcher.ts"
      to: "src/notifications/dispatcher.ts"
      via: "Trigger.dev task wrapping dispatch logic"
      pattern: "dispatchNotification"
---

<objective>
Build the WhatsApp notification system with WAHA/Twilio provider abstraction, push/digest/standard tier routing, structured command handling, and fatigue prevention.

Purpose: Enable real-time WhatsApp notifications for approval requests, post events, and structured command interaction between users and the system.
Output: Provider abstraction, notification dispatcher with fatigue limits, digest compiler, structured command parser, Trigger.dev tasks.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-team-coordination-and-notifications/07-RESEARCH.md
@.planning/phases/07-team-coordination-and-notifications/07-CONTEXT.md
@.planning/phases/07-team-coordination-and-notifications/07-01-PLAN.md
@.planning/phases/07-team-coordination-and-notifications/07-03-PLAN.md

# Existing Trigger.dev patterns
@src/trigger/analytics-collector.ts
@src/trigger/token-refresher.ts
@src/core/db/schema.ts
@src/notifications/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WAHA and Twilio WhatsApp provider implementations</name>
  <files>
    src/notifications/waha.ts
    src/notifications/twilio.ts
    src/notifications/provider.ts
  </files>
  <action>
    Create `src/notifications/waha.ts` — WAHA REST API client implementing WhatsAppProvider:

    `class WahaProvider implements WhatsAppProvider`:
    - Constructor: `(config: { baseUrl: string; session?: string; apiKey?: string })`
    - Default session = 'default'
    - All requests go to `${baseUrl}/api/...`
    - If apiKey provided, include in headers

    `sendText(to, body)`:
    - POST /api/sendText
    - Body: `{ session, chatId: formatChatId(to), text: body }`
    - formatChatId: phone number -> `${phone}@c.us`
    - Return MessageResult from response

    `sendButtons(to, body, buttons)`:
    - POST /api/send/buttons/reply (WAHA Plus feature)
    - Body: `{ session, chatId: formatChatId(to), body, buttons: buttons.map(b => ({ id: b.id, body: b.body })) }`
    - Fallback: if 4xx response (Core tier without button support), fall back to sendText with numbered options:
      `body + '\n\n' + buttons.map((b, i) => `${i+1}. ${b.body}`).join('\n') + '\n\nReply with a number to choose.'`

    `sendList(to, body, sections)`:
    - POST /api/sendList
    - Body: `{ session, chatId: formatChatId(to), body, title: 'Options', sections }`
    - Same fallback pattern as sendButtons for Core tier

    `sendImage(to, imageUrl, caption)`:
    - POST /api/sendImage
    - Body: `{ session, chatId: formatChatId(to), file: { url: imageUrl }, caption }`

    Create `src/notifications/twilio.ts` — Twilio REST API client implementing WhatsAppProvider:

    `class TwilioProvider implements WhatsAppProvider`:
    - Constructor: `(config: { accountSid: string; authToken: string; fromNumber: string })`
    - Base URL: `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`
    - Auth: Basic auth with `${accountSid}:${authToken}`

    `sendText(to, body)`:
    - POST Messages.json
    - Form body: `To=whatsapp:+${to}&From=whatsapp:+${fromNumber}&Body=${body}`
    - Parse response for MessageSid

    `sendButtons(to, body, buttons)`:
    - Twilio uses Content Templates for buttons
    - If ContentSid available (pre-registered template), use it
    - Fallback: send as text with numbered options (same as WAHA fallback)
    - In-session messages (within 24hr window) can use quick_reply content type

    `sendList(to, body, sections)`:
    - Twilio uses Content Templates for list messages
    - Fallback: send as text with formatted list

    `sendImage(to, imageUrl, caption)`:
    - POST Messages.json with MediaUrl parameter
    - Form body: `To=whatsapp:+${to}&From=whatsapp:+${fromNumber}&Body=${caption}&MediaUrl=${imageUrl}`

    Create `src/notifications/provider.ts` — Provider factory:

    `createWhatsAppProvider(config: WhatsAppProviderConfig): WhatsAppProvider`:
    - If config.provider === 'waha': return new WahaProvider(config.waha)
    - If config.provider === 'twilio': return new TwilioProvider(config.twilio)
    - Throw if neither configured

    `WhatsAppProviderConfig` interface:
    ```
    {
      provider: 'waha' | 'twilio';
      waha?: { baseUrl: string; session?: string; apiKey?: string };
      twilio?: { accountSid: string; authToken: string; fromNumber: string };
    }
    ```
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify both providers implement WhatsAppProvider interface. Verify button fallback to text for WAHA Core tier.
  </verify>
  <done>
    WAHA and Twilio providers implement WhatsAppProvider interface with button fallback to numbered text. Provider factory creates the configured provider.
  </done>
</task>

<task type="auto">
  <name>Task 2: Notification dispatcher with fatigue prevention</name>
  <files>
    src/notifications/dispatcher.ts
    src/trigger/notification-dispatcher.ts
  </files>
  <action>
    Create `src/notifications/dispatcher.ts`:

    `dispatchNotification(params: { db: DrizzleClient; provider: WhatsAppProvider; event: NotificationEvent; preferences: NotificationPreference }): Promise<DispatchResult>`:
    - Determine tier from NOTIFICATION_ROUTES[event.type]
    - Check fatigue limits (call checkFatigueLimits)
    - If tier is 'push' and fatigue limit exceeded: downgrade to 'digest' (queue for next digest)
    - If tier is 'push' and in quiet hours: hold until quiet hours end (schedule delayed dispatch)
    - If tier is 'digest': store event in notification_log with status='queued' for digest compiler
    - If tier is 'push' or 'standard' and passes checks:
      - Format message based on event type (formatNotificationMessage)
      - Determine whether to use buttons or text based on event type
      - Call provider.sendText/sendButtons as appropriate
      - Log to notification_log: { userId, eventType, tier, provider, recipient, status, messageId, sentAt }
    - Return DispatchResult: { sent: boolean; tier: string; downgraded?: boolean; reason?: string }

    `checkFatigueLimits(db, params: { userId: string; tier: string; eventType: string }): Promise<{ allowed: boolean; reason?: string }>`:
    - Check 1: Push count today < maxPushPerDay (default 3)
      - SELECT COUNT(*) FROM notification_log WHERE userId AND tier='push' AND sentAt > today_start AND status='sent'
    - Check 2: Cooldown — no push sent in last cooldownMinutes (default 120)
      - SELECT MAX(sentAt) FROM notification_log WHERE userId AND tier='push' AND status='sent'
    - Check 3: Dedup — no notification with same dedupKey in last 30 minutes
      - dedupKey = `${eventType}:${event.payload.postId || event.payload.key || ''}`
    - Return { allowed: true } or { allowed: false, reason: 'daily limit reached' | 'cooldown active' | 'duplicate' }

    `isQuietHours(preferences: NotificationPreference): boolean`:
    - Check if current time (in user's timezone) falls within quiet hours window
    - Handle midnight-crossing ranges (e.g., 22:00-08:00)

    `formatNotificationMessage(event: NotificationEvent): { body: string; buttons?: Array<{ id: string; body: string }> }`:
    - Switch on event.type:
      - 'approval.requested': "New post pending approval:\n\n\"{title}\"\n\nBy @{author} - scheduled for {time}" + buttons: [Approve, Reject, View]
      - 'post.failed': "Post failed after 3 retries:\n\n\"{title}\"\n\nPlatform: {platform}\nError: {error}" + buttons: [Retry, Cancel]
      - 'token.expiring': "{platform} token expires in {days} days. Re-authenticate to keep posting." + buttons: [Re-auth Now]
      - 'post.viral': "Your post is going viral! {metric}x above average.\n\n\"{title}\"" + buttons: [View Analytics]
      - 'approval.result': "Your post was {approved/rejected}.\n\n\"{title}\"\n{comment}" (no buttons)
      - 'post.published': "Post published to {platform}.\n\n\"{title}\"" (no buttons)

    `routeCompanyNotification(db, params: { hubId: string; eventType: string; payload: Record<string, unknown> }): Promise<string[]>`:
    - For company events (approval.requested), determine which team members should receive
    - approval.requested -> all admins of the hub
    - post.failed -> the post author
    - post.viral -> the post author + all admins
    - NOTIF-08: If team member has expertise tags matching the post pillar, prioritize them
    - Return array of userIds to notify

    Create `src/trigger/notification-dispatcher.ts`:

    Trigger.dev task `notification-dispatcher`:
    - Receives: { eventType, userId, hubId, payload }
    - Loads user's notification preferences from DB
    - Loads user's WhatsApp session from DB
    - If no WhatsApp session or session inactive: skip (no WhatsApp configured)
    - Creates provider via createWhatsAppProvider
    - Calls dispatchNotification
    - For company events: call routeCompanyNotification first to get target users, then dispatch to each
    - Returns: { dispatched: number, skipped: number, downgraded: number }
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify fatigue limits check all 3 conditions (daily cap, cooldown, dedup). Verify push-to-digest downgrade works. Verify quiet hours check.
  </verify>
  <done>
    Notification dispatcher routes events by tier, enforces fatigue limits (3 push/day, 2hr cooldown, 30min dedup, quiet hours), downgrades excess push to digest. Company notifications route to appropriate team members.
  </done>
</task>

<task type="auto">
  <name>Task 3: Structured command parser and conversation state</name>
  <files>
    src/notifications/commands.ts
  </files>
  <action>
    Create `src/notifications/commands.ts`:

    `parseIncomingCommand(message: string, buttonId?: string): ParsedCommand | null`:
    - If buttonId provided (WhatsApp button tap): map directly
      - 'approve' -> { command: 'approve' }
      - 'reject' -> { command: 'reject' }
      - 'view' -> { command: 'view' }
      - 'retry' -> { command: 'retry' }
      - 'r1', 'r2', 'r3' -> { command: 'select', index: 0|1|2 }
    - If text message: parse common patterns (text fallback per CONTEXT.md)
      - "approve" or "1" (when context is approval) -> { command: 'approve' }
      - "reject" or "2" -> { command: 'reject' }
      - "reject reason: {text}" or "reject: {text}" -> { command: 'reject', reason: text }
      - "r1", "r2", "r3" -> { command: 'select', index: 0|1|2 }
      - "skip" -> { command: 'skip' }
      - "list" -> { command: 'list' }
      - "help" -> { command: 'help' }
      - Numbers "1", "2", "3" -> context-dependent (approval or selection)
    - Return null if unrecognized

    `ParsedCommand` type:
    ```
    | { command: 'approve'; postId?: string }
    | { command: 'reject'; reason?: string; postId?: string }
    | { command: 'select'; index: number }
    | { command: 'view'; postId?: string }
    | { command: 'retry'; postId?: string }
    | { command: 'skip' }
    | { command: 'list' }
    | { command: 'help' }
    | { command: 'edit'; content?: string }
    | { command: 'post'; topic?: string }
    | { command: 'time'; time?: string }
    ```

    `processCommand(db, params: { userId: string; command: ParsedCommand; sessionState: ConversationState }): Promise<CommandResult>`:
    - Based on command type and current conversation context:
      - 'approve': if sessionState.pendingApprovalPostId set, approve that post. Otherwise, list pending approvals.
      - 'reject': if sessionState.pendingApprovalPostId set, reject with optional reason
      - 'select': if sessionState.options array exists, select the indexed option
      - 'list': return list of pending approvals or scheduled posts
      - 'help': return help text with available commands
      - 'skip': clear current conversation context
    - Return CommandResult: { response: string; buttons?: Button[]; updateState?: Partial<ConversationState> }

    `updateConversationState(db, params: { userId: string; state: Partial<ConversationState> }): Promise<void>`:
    - UPDATE whatsapp_sessions SET conversationContext = jsonb_set(conversationContext, ...), lastActivityAt = NOW()
    - ConversationState: { pendingApprovalPostId?: string; options?: Array<{ id: string; label: string }>; lastEventType?: string; lastEventAt?: string }

    `clearConversationState(db, userId: string): Promise<void>`:
    - Reset conversationContext to {} and update lastActivityAt
    - Called after successful command processing or after timeout (30 min inactivity)

    `HELP_TEXT` const:
    ```
    Available commands:
    - approve / 1 - Approve pending post
    - reject [reason] / 2 - Reject pending post
    - R1/R2/R3 - Select an option
    - skip - Skip current item
    - list - Show pending items
    - help - Show this message
    ```
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify parseIncomingCommand handles both button IDs and text input. Verify processCommand checks sessionState context.
  </verify>
  <done>
    Structured command parser handles WhatsApp button taps and text fallback. Conversation state machine tracks context per user. processCommand executes approval actions and list queries through WhatsApp.
  </done>
</task>

<task type="auto">
  <name>Task 4: Digest compiler and scheduled delivery</name>
  <files>
    src/notifications/digest.ts
    src/trigger/digest-compiler.ts
  </files>
  <action>
    Create `src/notifications/digest.ts`:

    `compileDigest(db, params: { userId: string; frequency: 'daily' | 'twice_daily' | 'weekly'; since: Date }): Promise<DigestContent>`:
    - Query notification_log WHERE userId AND status='queued' AND createdAt > since
    - Group events by category:
      - Published posts: count + highlights
      - Pending approvals: count + most urgent
      - Analytics highlights: top performing post, engagement trends
      - Upcoming schedule: next 3 scheduled posts
      - Downgraded push events: events that hit fatigue limits
    - Return DigestContent: { sections: DigestSection[], totalEvents: number, period: string }

    `formatDigestMessage(digest: DigestContent): string`:
    - Format for WhatsApp:
      ```
      Good morning! Here's your {daily/weekly} digest:

      Published: {count} posts
      {top post highlight if any}

      Pending: {count} approvals waiting
      {most urgent if any}

      Upcoming: {count} posts scheduled
      {next post preview}

      {downgraded events section if any}
      ```
    - Keep under WhatsApp's 4096 char limit
    - Adapt content depth to frequency: daily = highlights, weekly = full summary

    `DigestSection` interface: `{ title: string; content: string; count: number; priority: number }`
    `DigestContent` interface: `{ sections: DigestSection[]; totalEvents: number; period: string }`

    Create `src/trigger/digest-compiler.ts`:

    Trigger.dev scheduled task `digest-compiler`:
    - Schedule: runs every hour (checks which users need digests now)
    - For each user with digestEnabled:
      - Check if current hour matches their digestTime (in their timezone)
      - For twice_daily: check both morning and evening times (e.g., 08:00 and 18:00)
      - For weekly: check if today is Monday (or configured day)
      - Respect quiet hours (never send during quiet hours)
    - For each user needing a digest:
      - Calculate `since` date based on frequency (24h for daily, 12h for twice_daily, 7d for weekly)
      - Call compileDigest()
      - If digest has no events: skip (don't send empty digests)
      - Format and send via WhatsApp provider
      - Mark queued notification_log entries as 'sent'
    - Returns: { digestsSent: number, skipped: number, errors: number }
  </action>
  <verify>
    Run `pnpm exec tsc --noEmit`. Verify digest compiler respects timezone preferences. Verify empty digests are skipped.
  </verify>
  <done>
    Digest compiler aggregates queued events by category, formats for WhatsApp within 4096 char limit, delivers at user's configured time and frequency. Empty digests skipped. Scheduled task runs hourly checking delivery windows.
  </done>
</task>

</tasks>

<verification>
- [ ] `pnpm exec tsc --noEmit` passes with all notification files
- [ ] WAHA provider sends text, buttons, list, and image messages
- [ ] Twilio provider sends text and image messages with button fallback
- [ ] Button fallback to numbered text works for both providers
- [ ] Fatigue limits: 3 push/day cap enforced
- [ ] Fatigue limits: 2hr cooldown between pushes
- [ ] Fatigue limits: 30min dedup window
- [ ] Quiet hours prevent push delivery
- [ ] Push-to-digest downgrade on fatigue limit
- [ ] Structured commands parse both button IDs and text replies
- [ ] Conversation state tracked per user in whatsapp_sessions
- [ ] Digest compiler respects frequency and timezone
- [ ] Empty digests not sent
- [ ] Company notification routing sends to correct team members
</verification>

<success_criteria>
- WhatsApp provider abstraction allows swapping WAHA/Twilio without touching dispatch logic
- Push notifications deliver immediately for critical events
- Fatigue prevention avoids notification burnout
- Structured commands enable approve/reject/select through WhatsApp
- Digests compile and deliver at user's configured schedule
- Company notifications route to appropriate team members
</success_criteria>

<output>
After completion, create `.planning/phases/07-team-coordination-and-notifications/07-04-SUMMARY.md`
</output>
