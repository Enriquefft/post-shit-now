---
phase: 11-tech-debt-remediation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/db/api-keys.ts
  - src/core/db/schema.ts
autonomous: true
requirements:
  - CONFIG-04
  - IMG-01
  - IMG-02
  - IMG-03
  - IMG-04
  - IMG-05
  - VID-01
  - VID-02
  - VID-03
  - VID-04
  - VID-05

must_haves:
  truths:
    - "getApiKey() function retrieves and decrypts API keys from api_keys table"
    - "api_keys.userId stores hub owner (user ID for Personal Hub, hub ID for Company Hub)"
    - "setApiKey() function encrypts and stores API keys in api_keys table"
    - "listKeys() function returns all keys for a hub (without decrypting values)"
    - "Schema migration adds index on (userId, service) for efficient lookups"
  artifacts:
    - path: "src/core/db/api-keys.ts"
      provides: "Key management functions (get, set, list)"
      exports: ["getApiKey", "setApiKey", "listKeys"]
    - path: "drizzle/migrations/XXXX_add_api_keys_index.sql"
      provides: "Index on api_keys table for efficient lookups"
  key_links:
    - from: "src/core/db/api-keys.ts"
      to: "src/core/utils/crypto.ts"
      via: "import { encrypt, decrypt, keyFromHex }"
      pattern: "from.*crypto.*import.*\\{.*encrypt.*decrypt"
    - from: "src/core/db/api-keys.ts"
      to: "src/core/db/schema.ts"
      via: "apiKeys table reference"
      pattern: "apiKeys.*userId.*service"
---

<objective>
Create getApiKey/setApiKey/listKeys functions to manage hub-scoped API keys stored encrypted in api_keys table. These functions will be used by all provider modules to retrieve keys instead of reading process.env.

Purpose: Enable per-hub API key storage for multi-tenant architecture (Personal Hub uses user's keys, Company Hubs use company keys).
Output: src/core/db/api-keys.ts with CRUD operations, schema migration for index
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-should-we-address-this-remaining-tech-debt-issues-config-04-search-providers-read-from-process-env-byok-stores-in-keys-env-works-via-trigger-dev-env-vars-img-vid-providers-not-imported-by-generate-ts-claude-invoked-pattern-by-design/11-CONTEXT.md
@src/core/db/schema.ts
@src/core/utils/crypto.ts
</context>

<tasks>

<task type="auto">
  <name>Create getApiKey/setApiKey/listKeys functions</name>
  <files>src/core/db/api-keys.ts</files>
  <action>
Create src/core/db/api-keys.ts with:

1. Import: { apiKeys } from "../db/schema", { eq, and } from "drizzle-orm", { encrypt, decrypt, keyFromHex } from "../utils/crypto"
2. getApiKey(db, hubId, service, keyName?):
   - Load HUB_ENCRYPTION_KEY from process.env (or require as param)
   - Query api_keys where userId = hubId AND service = service (AND keyName = keyName if provided)
   - If not found: throw Error with helpful message "API key for {service} not found in hub {hubId}"
   - Decrypt using decrypt(encryptedValue, keyFromHex(HUB_ENCRYPTION_KEY))
   - Return decrypted plaintext
3. setApiKey(db, hubId, service, keyName, plaintextKey):
   - Load HUB_ENCRYPTION_KEY from process.env
   - Encrypt using encrypt(plaintextKey, keyFromHex(HUB_ENCRYPTION_KEY))
   - Insert/update api_keys row with userId = hubId, service, keyName, encryptedValue
4. listKeys(db, hubId):
   - Query api_keys where userId = hubId
   - Return array of { service, keyName } (do NOT decrypt values)
   - Optional: filter by service parameter

Use Drizzle ORM patterns from other query functions in the codebase.
  </action>
  <verify>
grep -n "export.*function.*getApiKey" src/core/db/api-keys.ts returns 1
grep -n "export.*function.*setApiKey" src/core/db/api-keys.ts returns 1
grep -n "export.*function.*listKeys" src/core/db/api-keys.ts returns 1
bun test src/core/db/api-keys.test.ts (if test exists)
  </verify>
  <done>
getApiKey() returns decrypted API key for given hubId + service
setApiKey() encrypts and stores API key in api_keys table
listKeys() returns service/keyName pairs for hub (no decrypted values)
  </done>
</task>

<task type="auto">
  <name>Add schema index for efficient key lookups</name>
  <files>drizzle/migrations/XXXX_add_api_keys_index.sql, src/core/db/schema.ts</files>
  <action>
Add unique index on api_keys table for efficient lookups:

1. Update schema.ts apiKeys table definition:
   - Add uniqueIndex("api_keys_user_service_idx").on(table.userId, table.service)

2. Generate migration via Drizzle Kit:
   - Run: bunx drizzle-kit generate:pg
   - This will create migration file with index SQL

3. Ensure RLS policy still works (api_keys_isolation should still reference userId correctly)
  </action>
  <verify>
grep -n "api_keys_user_service_idx" src/core/db/schema.ts returns 1
ls -la drizzle/migrations/ | grep -E "api_keys|index" | head -1 exists
  </verify>
  <done>
api_keys table has unique index on (userId, service) for O(1) lookups
Migration file generated and ready to apply
  </done>
</task>

</tasks>

<verification>
1. getApiKey() throws clear error when key not found for hubId + service
2. setApiKey() encrypts using HUB_ENCRYPTION_KEY before storing
3. listKeys() does NOT decrypt values (security best practice)
4. Index on (userId, service) exists in schema
5. Functions use Drizzle ORM patterns consistent with codebase
</verification>

<success_criteria>
getApiKey(), setApiKey(), and listKeys() functions exist and work with encrypted values.
Schema has index for efficient lookups.
No process.env API key reads in api-keys.ts (pure DB operations).
</success_criteria>

<output>
After completion, create `.planning/phases/11-should-we-address-this-remaining-tech-debt-issues-config-04-search-providers-read-from-process-env-byok-stores-in-keys-env-works-via-trigger-dev-env-vars-img-vid-providers-not-imported-by-generate-ts-claude-invoked-pattern-by-design/11-01-SUMMARY.md`
</output>
