---
phase: 26-tweet-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/utils/tweet-validator.ts
  - src/core/utils/thread-splitter.ts
  - src/core/utils/thread-splitter.test.ts
autonomous: true
requirements:
  - TVAL-01
  - TVAL-03

must_haves:
  truths:
    - "countTweetChars('hello') returns 5 (ASCII = weight 100)"
    - "countTweetChars with a URL returns 23 regardless of actual URL length"
    - "countTweetChars with emoji returns 2 per grapheme cluster (ZWJ sequences count as one unit)"
    - "countTweetChars with CJK characters returns 2 per character"
    - "validateTweet on 312-char text returns valid=false with error 'Tweet is 312/280 characters'"
    - "validateTweet with 11 mentions returns valid=true with a soft warning"
    - "thread-splitter uses countTweetChars instead of .length for all size comparisons"
  artifacts:
    - path: "src/core/utils/tweet-validator.ts"
      provides: "countTweetChars, validateTweet, TweetValidation type"
      exports: ["countTweetChars", "validateTweet", "TweetValidation"]
    - path: "src/core/utils/thread-splitter.ts"
      provides: "Thread splitting with weighted character counting"
      contains: "countTweetChars"
  key_links:
    - from: "src/core/utils/thread-splitter.ts"
      to: "src/core/utils/tweet-validator.ts"
      via: "import { countTweetChars }"
      pattern: "import.*countTweetChars.*tweet-validator"
---

<objective>
Create the weighted tweet character counting utility and refactor the thread splitter to use it.

Purpose: Tweets with URLs, emojis, and CJK characters are currently counted using naive `.length`, causing oversized tweets to slip through and hit misleading X API 403 errors. This plan creates the single source of truth for tweet character counting (TVAL-03) and implements X's v3 weighted counting algorithm (TVAL-01).

Output: `tweet-validator.ts` with `countTweetChars()` and `validateTweet()`, refactored `thread-splitter.ts` using weighted counting.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-tweet-validation/26-CONTEXT.md
@.planning/phases/26-tweet-validation/26-RESEARCH.md
@src/core/utils/thread-splitter.ts
@src/core/types/index.ts

<interfaces>
<!-- Key types and contracts the executor needs -->

From src/core/utils/thread-splitter.ts:
```typescript
export function splitIntoThread(text: string, maxLen = 280): string[];
export function formatThreadPreview(tweets: string[]): { preview: string; tweetCount: number; warning: string | null; };
```

From src/core/types/index.ts:
```typescript
export type Platform = "x" | "linkedin" | "instagram" | "tiktok";
export interface PlatformPublishResult { platform: Platform; status: "published" | "failed" | "skipped"; externalPostId?: string; error?: string; }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tweet-validator.ts with weighted character counting</name>
  <files>src/core/utils/tweet-validator.ts</files>
  <action>
Create `src/core/utils/tweet-validator.ts` implementing X's v3 weighted character counting algorithm (~60-80 lines).

**Constants (from X's v3.json config):**
- `SCALE = 100`, `DEFAULT_WEIGHT = 200` (2 chars), `MAX_WEIGHTED = 280`, `URL_WEIGHT = 23`
- Weight-100 ranges (1 char each): `[0, 4351]` (Latin-1 + extensions), `[8192, 8205]` (general punctuation through ZWJ), `[8208, 8223]` (dashes/quotation marks), `[8242, 8247]` (prime marks)

**`countTweetChars(text: string): number`:**
1. NFC-normalize the text: `text.normalize('NFC')`
2. Detect URLs with robust regex: `https?:\/\/[^\s<>"]+` and bare domains `(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z]{2,}(?:\/[^\s<>"]*)?` ‚Äî strip them from text, count each as 23 chars
3. Use `Intl.Segmenter('en', { granularity: 'grapheme' })` to iterate grapheme clusters of the URL-stripped text
4. For each grapheme, check first code point against weight-100 ranges. If in range: weight 100 (1 char). Otherwise: weight 200 (2 chars, covers emoji, CJK, etc.)
5. Return `Math.ceil((urlWeightedTotal + charWeightedTotal) / SCALE)`

**`TweetValidation` interface:**
```typescript
interface TweetValidation {
  valid: boolean;       // false only for hard errors (char count > 280)
  charCount: number;    // weighted character count
  maxChars: number;     // 280
  errors: string[];     // hard blockers
  warnings: string[];   // soft advisories
}
```

**`validateTweet(text: string): TweetValidation`:**
1. Call `countTweetChars(text)`
2. If charCount > 280: push error `"Tweet is {charCount}/280 characters"` (per user decision: no type breakdown)
3. If mentions (/@\w+/g) > 10: push warning `"{count} mentions detected (recommended max: 10)"`
4. If hashtags (/#\w+/g) > 5: push warning `"{count} hashtags detected (recommended max: 5)"`
5. Return `{ valid: errors.length === 0, charCount, maxChars: 280, errors, warnings }`

Export: `countTweetChars`, `validateTweet`, and `TweetValidation` type.

**Edge cases to handle:**
- Empty string returns 0
- Strip zero-width characters from URL detection but count them normally (they have weight 100 in range 8192-8205)
- Trim trailing sentence punctuation from URL matches (`.`, `,`, `)` at end of URL if preceded by non-URL char)
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>
- `countTweetChars('hello')` returns 5
- `countTweetChars('Check https://example.com/path')` returns 29 (6 + 23)
- `countTweetChars('Hello üåç')` returns 8 (6 + 2)
- Emoji ZWJ sequence (family emoji) counts as 2 chars
- CJK character counts as 2 chars
- `validateTweet` returns `valid: false` with error string for oversized tweets
- `validateTweet` returns soft warnings for excess mentions/hashtags
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor thread-splitter.ts to use countTweetChars</name>
  <files>src/core/utils/thread-splitter.ts</files>
  <action>
Refactor `src/core/utils/thread-splitter.ts` to use `countTweetChars()` from `tweet-validator.ts` instead of `.length` for all character comparisons.

**Changes:**

1. Add import: `import { countTweetChars } from './tweet-validator.ts';`

2. In `splitIntoThread()`:
   - Line 34: `first.length <= maxLen` -> `countTweetChars(first) <= maxLen`
   - Line 42: `paragraph.length <= maxLen` -> `countTweetChars(paragraph) <= maxLen`
   - Add thread suffix space reservation per user decision: when splitting produces >1 tweet, reduce effective maxLen by suffix length. Suffix format: ` {i}/{total}`. For threads <= 9: suffix is 4 chars (` 1/3`). For 10: suffix is 5 chars (` 1/10`). Estimate thread count first pass, then adjust.
   - Add max thread length cap: if result > 10 tweets, truncate and add warning (per user decision: max 10 tweets)

3. In `splitBySentences()`:
   - Line 64: `sentence.length > maxLen` -> `countTweetChars(sentence) > maxLen`
   - Line 73: `merged.length <= maxLen` -> `countTweetChars(merged) <= maxLen`

4. In `splitByWords()`:
   - Line 98: `merged.length <= maxLen` -> `countTweetChars(merged) <= maxLen`

5. In `formatThreadPreview()`:
   - Line 125: `tweet.length` -> `countTweetChars(tweet)` for char count display
   - Add fraction suffix to preview: `"1/3 (245 chars)\n{tweet text}"` format
   - Update warning threshold from 7 to 10 (per user decision: max 10 tweets)

6. Add fraction suffix numbering to `splitIntoThread()` return value: append ` {i+1}/{total}` to each tweet text (per user decision: "1/3" appended to each tweet).

**Important:** The suffix must be appended AFTER splitting but the space for it must be reserved BEFORE splitting. Two-pass approach:
- Pass 1: Split with reduced maxLen (maxLen - estimated suffix length)
- Pass 2: Append actual suffix based on actual tweet count
- If tweet count changes suffix length (9->10 tweets changes suffix from 4 to 5 chars), re-split with correct reservation
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>
- All `.length` comparisons in thread-splitter.ts replaced with `countTweetChars()` calls
- Thread splitting reserves space for fraction suffix before splitting
- Each tweet in output has ` {i}/{total}` suffix appended
- `formatThreadPreview` uses weighted char counts
- Max thread length capped at 10 tweets
- No duplicate character counting logic exists (thread-splitter imports from tweet-validator)
  </done>
</task>

</tasks>

<verification>
- `bun run typecheck` passes with no new errors
- `grep -r '\.length' src/core/utils/thread-splitter.ts` shows no raw .length comparisons for character counting (only array .length is acceptable)
- `grep 'countTweetChars' src/core/utils/thread-splitter.ts` confirms import and usage
- `grep 'countTweetChars' src/core/utils/tweet-validator.ts` confirms export
</verification>

<success_criteria>
1. `tweet-validator.ts` exists with exported `countTweetChars()` and `validateTweet()`
2. `thread-splitter.ts` imports and uses `countTweetChars()` for ALL size comparisons (TVAL-03 single source of truth)
3. Weighted counting handles URLs (=23), emojis (=2), CJK (=2), Latin (=1) correctly (TVAL-01)
4. Thread splitting reserves space for fraction suffixes before splitting
5. `bun run typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/26-tweet-validation/26-01-SUMMARY.md`
</output>
