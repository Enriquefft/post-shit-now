---
phase: 02-x-platform-pipeline
plan: 04
type: execute
wave: 3
depends_on:
  - 02-02
  - 02-03
files_modified:
  - src/trigger/publish-post.ts
  - src/cli/post.ts
  - .claude/commands/psn/post.md
  - src/trigger/watchdog.ts
autonomous: false
requirements:
  - SCHED-01
  - SCHED-02
  - SCHED-04
  - SCHED-05

must_haves:
  truths:
    - "User can schedule a post for a specific date/time and it publishes at that time via Trigger.dev delayed run"
    - "User can post immediately without going through scheduler delay"
    - "Failed posts are marked with status:failed, preserve content, and are surfaced to user on next interaction"
    - "Threads are posted sequentially with partial failure tracking per tweet"
    - "Posts transition through statuses: draft -> scheduled -> publishing -> published/failed with sub-statuses"
    - "User can edit or cancel a scheduled post (cancel Trigger.dev run, create new one on edit)"
  artifacts:
    - path: "src/trigger/publish-post.ts"
      provides: "Trigger.dev task that publishes posts (single tweets, threads, with media)"
      exports: ["publishPost"]
      min_lines: 100
    - path: "src/cli/post.ts"
      provides: "Post creation and scheduling CLI script"
      exports: ["createPost", "schedulePost", "cancelPost", "editScheduledPost", "postNow"]
      min_lines: 100
    - path: ".claude/commands/psn/post.md"
      provides: "Slash command for /psn:post"
    - path: "src/trigger/watchdog.ts"
      provides: "Updated watchdog that re-triggers stuck posts via publishPost task"
      contains: "publishPost"
  key_links:
    - from: "src/trigger/publish-post.ts"
      to: "src/platforms/x/client.ts"
      via: "XClient for tweet creation and thread posting"
      pattern: "XClient|createTweet|postThread"
    - from: "src/trigger/publish-post.ts"
      to: "src/platforms/x/media.ts"
      via: "uploadMedia for image posts"
      pattern: "uploadMedia"
    - from: "src/trigger/publish-post.ts"
      to: "src/core/utils/crypto.ts"
      via: "decrypt token before API call"
      pattern: "decrypt"
    - from: "src/cli/post.ts"
      to: "src/trigger/publish-post.ts"
      via: "publishPost.trigger() with delay for scheduling"
      pattern: "publishPost\\.trigger"
    - from: "src/cli/post.ts"
      to: "src/core/utils/thread-splitter.ts"
      via: "splitIntoThread for thread composition"
      pattern: "splitIntoThread"
    - from: "src/cli/post.ts"
      to: "src/core/utils/timezone.ts"
      via: "userTimeToUtc for schedule time conversion"
      pattern: "userTimeToUtc"
    - from: "src/trigger/watchdog.ts"
      to: "src/trigger/publish-post.ts"
      via: "re-trigger stuck posts"
      pattern: "publishPost\\.trigger"
---

<objective>
Build the publish-post Trigger.dev task, the post creation/scheduling CLI, the /psn:post slash command, and update the watchdog to re-trigger stuck posts.

Purpose: This is the user-facing plan that ties everything together. The user creates a post via CLI, schedules or posts immediately, and the Trigger.dev task handles reliable publishing with retry, rate limit respect, and thread support. This completes the Phase 2 pipeline from "user writes content" to "content appears on X."

Output: Full post scheduling and publishing pipeline, /psn:post command, updated watchdog.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-x-platform-pipeline/02-RESEARCH.md
@.planning/phases/02-x-platform-pipeline/02-01-SUMMARY.md
@.planning/phases/02-x-platform-pipeline/02-02-SUMMARY.md
@.planning/phases/02-x-platform-pipeline/02-03-SUMMARY.md

@src/platforms/x/client.ts
@src/platforms/x/media.ts
@src/platforms/x/oauth.ts
@src/core/db/schema.ts
@src/core/types/index.ts
@src/core/utils/thread-splitter.ts
@src/core/utils/timezone.ts
@src/core/utils/crypto.ts
@src/core/utils/env.ts
@src/trigger/watchdog.ts
@src/cli/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Publish-post Trigger.dev task with thread support and retry</name>
  <files>src/trigger/publish-post.ts</files>
  <action>
Create the core publish-post task. This is the task that fires at scheduled time (or immediately) to publish content to X.

`publishPost` — `task()` from @trigger.dev/sdk:
- `id: "publish-post"`
- `retry: { maxAttempts: 3, factor: 2, minTimeoutInMs: 2000, maxTimeoutInMs: 30000 }` — per SCHED-04
- `maxDuration: 300` — 5 minutes (threads + media can take time)

`run` function payload: `{ postId: string }`

**Flow:**
1. Load env: DATABASE_URL, HUB_ENCRYPTION_KEY, X_CLIENT_ID, X_CLIENT_SECRET. If any missing, throw error (will be caught by Trigger.dev retry).
2. Create DB connection. Fetch post by ID from posts table.
3. If post not found or status not in ["scheduled", "retry"]: log warning, return early (idempotent — prevents double-publish).
4. Update post status to "publishing", subStatus to null.
5. Fetch oauth_token for platform='x' and the post's userId. If no token found, mark post as failed with failReason "no_oauth_token", return.
6. If token is expired (expiresAt < now): attempt inline refresh using Arctic refreshAccessToken. If refresh fails, mark post as failed with failReason "token_expired_refresh_failed", set metadata.requiresReauth=true, return. If refresh succeeds, store both new tokens encrypted atomically.
7. Decrypt access token. Create `XClient` instance.
8. **Check for media:** If post.mediaUrls is non-empty, upload each media file:
   - Read file from local path (mediaUrls stores local file paths)
   - Update subStatus to "media_uploading"
   - Call `uploadMedia` for each file
   - Update subStatus to "media_uploaded"
   - Collect media IDs
9. **Determine if thread:** Check if content length > 280 or if post has child posts (parentPostId check).
   - If content is a JSON array (thread tweets stored as JSON string array in content): parse as string[]
   - If content is plain text > 280: this shouldn't happen (CLI splits before storing), but handle gracefully by splitting with `splitIntoThread`
10. **Single tweet:** Call `client.createTweet({ text: content, mediaIds })`. On success: update post to "published", store externalPostId, publishedAt = now.
11. **Thread:** Call `client.postThread(tweets, mediaIdsPerTweet)`.
    - Track partial success: for each tweet posted, store its platform ID in `platformPostIds` array on the parent post.
    - If a tweet fails mid-thread: update subStatus to "thread_partial", store which tweets succeeded in metadata (`{ threadProgress: { posted: number, total: number, lastPostedId: string } }`), then throw to trigger retry.
    - On retry: check metadata.threadProgress, resume from the failure point (skip already-posted tweets).
12. **Rate limit handling (SCHED-04):** If XApiError with isRateLimit:
    - Update subStatus to "rate_limited"
    - Store rateLimitResetAt in metadata
    - Use `wait.until(rateLimit.resetAt)` from @trigger.dev/sdk to pause until rate limit resets (no compute cost during wait)
    - After wait, retry the failed API call
13. **Final failure:** After all Trigger.dev retries exhausted (3 attempts), the task fails. Trigger.dev will mark it as failed. The watchdog will catch posts stuck in "publishing" state and mark them as "failed" with preserved content.

Import `task`, `logger`, `wait` from "@trigger.dev/sdk".
  </action>
  <verify>Run `bun run check` — no type errors. Verify the task handles: single tweet, thread, media upload, rate limit wait, token refresh, partial thread failure, and status transitions.</verify>
  <done>publish-post task handles single tweets, threads (sequential with partial failure tracking), media uploads, inline token refresh, and rate limit backoff via wait.until(). Status transitions: scheduled/retry -> publishing -> published/failed with sub-statuses.</done>
</task>

<task type="auto">
  <name>Task 2: Post CLI script, slash command, and watchdog update</name>
  <files>src/cli/post.ts, .claude/commands/psn/post.md, src/trigger/watchdog.ts</files>
  <action>
**Post CLI (src/cli/post.ts):**

Create the post creation and scheduling CLI following existing CLI patterns (JSON output to stdout, Claude interprets).

Functions (all return JSON-serializable results):

1. `createPost(params: { content: string; platform: Platform; mediaFiles?: string[]; scheduledAt?: string; scheduledTime?: string; timezone?: string }): Promise<CreatePostResult>`:
   - Load hub.env for DB connection and encryption key
   - If content length > 280 and platform is "x": auto-split using `splitIntoThread(content)`
   - If thread: return preview using `formatThreadPreview(tweets)` with `status: "preview"` and `{ tweets, tweetCount, warning }` for Claude to present to user
   - If not thread or already approved: insert post into DB with status "draft"
   - Return `{ postId, status: "draft", content, platform, isThread, tweetCount? }`

2. `schedulePost(params: { postId: string; date: string; time: string; timezone?: string }): Promise<SchedulePostResult>`:
   - Load hub.env for timezone default if not provided
   - Convert user time to UTC using `userTimeToUtc(date, time, timezone)`
   - Update post status to "scheduled", set scheduledAt
   - Trigger publishPost with delay: `publishPost.trigger({ postId }, { delay: utcDate })`
   - Store triggerRunId in post record
   - Return `{ postId, scheduledAt: utcDate.toISOString(), scheduledAtLocal: utcToUserTime(utcDate, timezone).full, triggerRunId }`

3. `postNow(params: { postId: string }): Promise<PostNowResult>`:
   - Update post status to "scheduled" (immediate transition)
   - Trigger publishPost with NO delay: `publishPost.trigger({ postId })`
   - Store triggerRunId
   - Return `{ postId, triggerRunId, status: "publishing" }`

4. `cancelPost(params: { postId: string }): Promise<CancelResult>`:
   - Fetch post, get triggerRunId from record
   - Call `runs.cancel(triggerRunId)` from @trigger.dev/sdk
   - Update post status to "draft", clear scheduledAt and triggerRunId
   - Return `{ postId, status: "cancelled" }`

5. `editScheduledPost(params: { postId: string; content?: string; date?: string; time?: string; timezone?: string }): Promise<EditResult>`:
   - Fetch post, get old triggerRunId
   - Cancel old run: `runs.cancel(oldRunId)`
   - Update post content if provided
   - If new date/time: convert to UTC, create new delayed run
   - If only content changed (no date change): create new delayed run with same scheduledAt
   - Store new triggerRunId
   - Return `{ postId, status: "scheduled", triggerRunId: newRunId }`

6. `getRecentFailures(): Promise<FailedPost[]>`:
   - Query posts with status "failed" from last 7 days
   - Return array with postId, content (truncated), failReason, failedAt
   - This is surfaced by /psn:post preamble (per user decision: failures shown when relevant)

Add `import.meta.main` entry point that reads command from argv and dispatches.

**Slash command (.claude/commands/psn/post.md):**

Create the /psn:post command file. This is a prompt for Claude, not executable code. Structure:

```
# /psn:post — Create and schedule posts

## What this does
Creates, schedules, and manages posts for X.

## Flow
1. Check for recent failures: Run `bun run src/cli/post.ts failures` and show any failed posts
2. Ask user what they want to post (or accept content from arguments)
3. If content > 280 chars for X: show thread preview, ask for approval/edits
4. Ask: "Post now or schedule?"
   - Schedule: ask for date and time (interpret in user's configured timezone)
   - Post now: confirm and post immediately
5. Create post in DB, trigger via Trigger.dev
6. Confirm: show post ID, scheduled time (in user's timezone), platform

## Commands
- Create: `bun run src/cli/post.ts create --content "..." --platform x`
- Schedule: `bun run src/cli/post.ts schedule --post-id UUID --date 2026-03-15 --time 09:00`
- Post now: `bun run src/cli/post.ts now --post-id UUID`
- Cancel: `bun run src/cli/post.ts cancel --post-id UUID`
- Edit: `bun run src/cli/post.ts edit --post-id UUID --content "..." --date 2026-03-16 --time 10:00`
- Failures: `bun run src/cli/post.ts failures`
```

Include instructions for Claude to handle the thread preview approval flow (per user decision: show full preview, user approves or adjusts).

**Watchdog update (src/trigger/watchdog.ts):**

Update the existing watchdog to actually re-trigger stuck posts (Phase 1 left a "Phase 2 will add re-trigger logic" comment):

1. Import `publishPost` from `./publish-post.ts`
2. In the stuck scheduled posts handler: instead of just marking as "retry", trigger `publishPost.trigger({ postId: post.id })` with no delay
3. Store the new triggerRunId in the post's metadata
4. Limit retries: check metadata for retryCount. If retryCount >= 3, mark as "failed" instead of retrying (per SCHED-04: 3 retries max).
5. Increment retryCount in metadata on each watchdog retry.
  </action>
  <verify>Run `bun run check` — no type errors. Verify post.ts exports all 6 functions. Verify /psn:post.md slash command file exists with flow description. Verify watchdog.ts now imports and triggers publishPost for stuck posts.</verify>
  <done>Post CLI provides create/schedule/cancel/edit/postNow/getRecentFailures. /psn:post slash command guides Claude through the full posting flow. Watchdog re-triggers stuck posts via publishPost task with retry counting.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete posting pipeline</name>
  <files>src/trigger/publish-post.ts, src/cli/post.ts, .claude/commands/psn/post.md, src/trigger/watchdog.ts</files>
  <action>Human verifies the full posting pipeline from Tasks 1-2.</action>
  <verify>
    1. Run `bun run check` — should pass with no errors
    2. Inspect src/trigger/publish-post.ts — should handle single tweets, threads, media, rate limits, token refresh
    3. Inspect src/cli/post.ts — should export createPost, schedulePost, postNow, cancelPost, editScheduledPost, getRecentFailures
    4. Inspect .claude/commands/psn/post.md — should describe the full posting flow
    5. Inspect src/trigger/watchdog.ts — should now import and trigger publishPost for stuck posts
    6. Verify the status flow: draft -> scheduled -> publishing -> published/failed with sub-statuses
  </verify>
  <done>Complete posting pipeline verified: publish task, CLI, slash command, and watchdog update all working.</done>
</task>

</tasks>

<verification>
- `bun run check` passes
- Publish-post task handles: single tweet, thread (sequential), media upload, rate limit wait, inline token refresh, partial thread failure with resume
- Post CLI provides full lifecycle: create -> schedule/postNow -> cancel/edit -> get failures
- Watchdog re-triggers stuck posts with retry counting (max 3)
- Status transitions enforced: draft -> scheduled -> publishing -> published/failed
- Thread partial failures tracked in metadata with resume capability
- /psn:post slash command provides clear flow for Claude to follow
</verification>

<success_criteria>
- User can create a post, schedule it, and have it publish at the scheduled time
- User can post immediately without scheduler delay
- User can cancel or edit a scheduled post
- Thread composition with preview and approval works
- Failed posts are preserved with content and reason, surfaced on next interaction
- Watchdog catches and re-triggers stuck posts (replacing Phase 1 placeholder)
</success_criteria>

<output>
After completion, create `.planning/phases/02-x-platform-pipeline/02-04-SUMMARY.md`
</output>
