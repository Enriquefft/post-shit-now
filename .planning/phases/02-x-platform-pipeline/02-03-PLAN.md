---
phase: 02-x-platform-pipeline
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/platforms/x/client.ts
  - src/platforms/x/media.ts
  - src/trigger/token-refresher.ts
autonomous: true
requirements:
  - PLAT-05
  - AUTH-05
  - AUTH-06
  - AUTH-07
  - SCHED-03

must_haves:
  truths:
    - "X API client tracks rate limits from response headers and throws typed errors on 429"
    - "Token refresher runs on a cron schedule, uses SELECT FOR UPDATE SKIP LOCKED, and stores both new access AND refresh tokens atomically"
    - "Token refresh failure is recorded in oauth_tokens metadata for surfacing to user"
    - "Media upload returns a media_id that can be attached to tweets"
  artifacts:
    - path: "src/platforms/x/client.ts"
      provides: "Typed X API client with rate limit tracking"
      exports: ["XClient"]
      min_lines: 80
    - path: "src/platforms/x/media.ts"
      provides: "X media upload helper (simple upload for images)"
      exports: ["uploadMedia"]
      min_lines: 30
    - path: "src/trigger/token-refresher.ts"
      provides: "Scheduled token refresh cron task with row-level locking"
      exports: ["tokenRefresher"]
      min_lines: 60
  key_links:
    - from: "src/platforms/x/client.ts"
      to: "https://api.x.com"
      via: "fetch with Bearer token"
      pattern: "api\\.x\\.com"
    - from: "src/platforms/x/client.ts"
      to: "src/platforms/x/types.ts"
      via: "Zod schema validation of responses"
      pattern: "parse|safeParse"
    - from: "src/trigger/token-refresher.ts"
      to: "src/platforms/x/oauth.ts"
      via: "refreshAccessToken call"
      pattern: "refreshAccessToken"
    - from: "src/trigger/token-refresher.ts"
      to: "src/core/utils/crypto.ts"
      via: "decrypt old token, encrypt new tokens"
      pattern: "decrypt|encrypt"
    - from: "src/trigger/token-refresher.ts"
      to: "Postgres SELECT FOR UPDATE SKIP LOCKED"
      via: "db.execute raw SQL"
      pattern: "FOR UPDATE SKIP LOCKED"
---

<objective>
Build the X API client with rate limit awareness, media upload support, and the token refresher cron task with race-condition-safe locking.

Purpose: The X API client is the typed interface through which all X interactions happen. The token refresher ensures tokens stay valid without manual intervention. These are the runtime engines that the publish-post task (Plan 04) will use.

Output: Production-ready X API client, media upload helper, and token refresh cron task.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-x-platform-pipeline/02-RESEARCH.md
@.planning/phases/02-x-platform-pipeline/02-01-SUMMARY.md

@src/platforms/x/types.ts
@src/platforms/x/oauth.ts
@src/core/db/schema.ts
@src/core/db/connection.ts
@src/core/utils/crypto.ts
@src/core/utils/env.ts
@src/trigger/watchdog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: X API client with rate limit tracking and media upload</name>
  <files>src/platforms/x/client.ts, src/platforms/x/media.ts</files>
  <action>
**X API client (src/platforms/x/client.ts):**

Create a class-based typed X API client. Use raw `fetch` (not a third-party SDK — per research recommendation).

`class XClient`:
- Constructor takes `accessToken: string`. Stores it as a private field.
- Private `rateLimits: Map<string, RateLimitInfo>` — tracks rate limits per endpoint category.
- Private `async request<T>(endpoint: string, options: RequestInit, schema?: ZodSchema<T>): Promise<{ data: T; rateLimit: RateLimitInfo }>`:
  - Builds full URL: `https://api.x.com${endpoint}`
  - Sets headers: `Authorization: Bearer ${this.accessToken}`, `Content-Type: application/json`
  - Executes fetch
  - Reads rate limit headers: `x-rate-limit-limit`, `x-rate-limit-remaining`, `x-rate-limit-reset` (Unix timestamp -> Date)
  - Stores rate limit info in `this.rateLimits` keyed by endpoint
  - On 429: throw `RateLimitError` with rate limit info
  - On non-ok: throw `XApiError` with status code, body text, rate limit info
  - If schema provided: validate response with `schema.parse(json)` (throws ZodError on mismatch)
  - Return `{ data, rateLimit }`

- `async createTweet(params: { text: string; replyToId?: string; mediaIds?: string[] }): Promise<{ id: string; text: string; rateLimit: RateLimitInfo }>`:
  - Build body from TweetCreateSchema shape
  - If replyToId: add `reply: { in_reply_to_tweet_id: replyToId }`
  - If mediaIds: add `media: { media_ids: mediaIds }`
  - POST to `/2/tweets`
  - Validate response with TweetResponseSchema
  - Return `{ id: data.data.id, text: data.data.text, rateLimit }`

- `async postThread(tweets: string[], mediaIdsPerTweet?: (string[] | undefined)[]): Promise<{ tweetIds: string[]; rateLimits: RateLimitInfo[] }>`:
  - Post tweets SEQUENTIALLY (each needs previous tweet's ID — per pitfall #2)
  - First tweet: no replyToId
  - Subsequent tweets: replyToId = previous tweet's ID
  - Track all posted IDs in array
  - If mediaIdsPerTweet provided, attach media to corresponding tweet
  - Return all tweet IDs and rate limits

- `getRateLimit(endpoint: string): RateLimitInfo | undefined` — getter for current rate limit info
- `isRateLimited(endpoint: string): boolean` — checks if remaining is 0 and resetAt is in the future

**Media upload (src/platforms/x/media.ts):**

`async function uploadMedia(imageBuffer: Buffer, mimeType: string, accessToken: string): Promise<{ mediaId: string }>`:
- Build FormData: append "media" as Blob with mimeType, append "media_category" as "tweet_image"
- POST to `https://api.x.com/2/media/upload`
- Headers: `Authorization: Bearer ${accessToken}` (do NOT set Content-Type — let browser set multipart boundary)
- Validate response with MediaUploadResponseSchema
- Return `{ mediaId: result.media_id }`
- On error: throw descriptive error with status code

Export both `uploadMedia` and the `XClient` class.
  </action>
  <verify>Run `bun run check` — no type errors. Verify XClient class has createTweet, postThread, getRateLimit methods. Verify uploadMedia function exists in media.ts.</verify>
  <done>XClient class provides typed X API access with rate limit tracking from response headers. Media upload helper handles simple image upload via FormData to X API v2. Thread posting is sequential with each tweet using the previous tweet's ID as replyToId.</done>
</task>

<task type="auto">
  <name>Task 2: Token refresher cron task with row-level locking</name>
  <files>src/trigger/token-refresher.ts</files>
  <action>
Create the token refresher Trigger.dev cron task following the existing pattern from watchdog.ts.

`tokenRefresher` — `schedules.task`:
- `id: "token-refresher"`
- `cron: "0 */6 * * *"` — every 6 hours (per research: access tokens expire in 2 hours, 4x daily refresh is sufficient)
- `maxDuration: 120` — 2 minutes max

`run` function:
1. Load DATABASE_URL and HUB_ENCRYPTION_KEY from process.env (Trigger.dev tasks receive env vars from the project). If missing, log error and return.
2. Create DB connection via `createHubConnection(databaseUrl)`.
3. Create encryption key buffer via `keyFromHex(encryptionKey)`.
4. **SELECT FOR UPDATE SKIP LOCKED** — find tokens needing refresh:
   ```sql
   SELECT id, user_id, platform, access_token, refresh_token, expires_at, metadata
   FROM oauth_tokens
   WHERE platform = 'x'
     AND refresh_token IS NOT NULL
     AND expires_at < NOW() + INTERVAL '1 day'
   FOR UPDATE SKIP LOCKED
   LIMIT 10
   ```
   Use `db.execute(sql\`...\`)` with raw SQL (per pitfall #6: Drizzle doesn't have FOR UPDATE). Note: refresh when access token expires within 1 day, not 7 days — access tokens are only 2 hours, so "within 1 day" catches all expiring tokens.

5. For each locked token row:
   a. Decrypt refresh_token using `decrypt(token.refresh_token, encKey)`
   b. Load X_CLIENT_ID, X_CLIENT_SECRET from process.env
   c. Create Arctic Twitter client, call `refreshAccessToken(client, decryptedRefresh)`
   d. Encrypt BOTH new access token AND new refresh token (CRITICAL: X refresh tokens are one-time use per pitfall #1)
   e. Update the row atomically: new access_token, new refresh_token, new expires_at, updated_at = now(), metadata with lastRefreshAt timestamp
   f. Log success per token

6. **Error handling per token** (don't let one failure stop others):
   - Wrap each token refresh in try/catch
   - On failure: update the token row's metadata with `{ refreshError: error.message, refreshFailedAt: new Date().toISOString(), requiresReauth: true }` (AUTH-07: user notified on next interaction)
   - Log the error with token ID (not the token value!)
   - Continue to next token

7. Return summary: `{ total: number; refreshed: number; failed: number; skipped: number }`

Import types from existing modules. Follow the watchdog.ts pattern for structure.
  </action>
  <verify>Run `bun run check` — no type errors. Verify the task uses `schedules.task` with cron. Verify raw SQL contains `FOR UPDATE SKIP LOCKED`. Verify both access and refresh tokens are updated atomically.</verify>
  <done>Token refresher runs every 6 hours, selects tokens expiring within 1 day using row-level locking, refreshes via Arctic, stores BOTH new tokens encrypted, and records failures in metadata for user notification on next interaction (AUTH-07).</done>
</task>

</tasks>

<verification>
- `bun run check` passes
- X client uses `https://api.x.com` base URL with Bearer token auth
- X client reads `x-rate-limit-*` headers from every response
- X client throws RateLimitError on 429 with rate limit info
- Thread posting in postThread is sequential (for loop, not Promise.all)
- Token refresher uses `SELECT FOR UPDATE SKIP LOCKED` raw SQL
- Token refresher stores BOTH new access AND refresh tokens
- Token refresher records failure metadata for AUTH-07 notification
- Media upload uses FormData with Blob (not JSON body)
</verification>

<success_criteria>
- XClient provides typed, rate-limit-aware access to X API v2
- Media upload handles simple image upload returning media_id
- Token refresher safely handles concurrent execution via row-level locking
- Token refresh failures are recorded for user notification
- All code passes type checking and linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-x-platform-pipeline/02-03-SUMMARY.md`
</output>
