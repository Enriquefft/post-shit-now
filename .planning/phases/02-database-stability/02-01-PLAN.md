---
phase: 02-database-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/core/db/migrate.ts, src/core/db/connection.ts]
autonomous: true
requirements: [M1]

must_haves:
  truths:
    - "Migration failures are caught and reported with actionable error messages"
    - "Partial migration failures can be retried without manual intervention"
    - "Migration verification confirms all required tables exist"
  artifacts:
    - path: "src/core/db/migrate.ts"
      provides: "Migration runner with retry logic and verification"
      min_lines: 30
    - path: "src/core/db/connection.ts"
      provides: "Connection factory for migration verification"
      exports: ["createHubConnection"]
  key_links:
    - from: "src/core/db/migrate.ts"
      to: "drizzle-orm/neon-http/migrator"
      via: "migrate() function call"
      pattern: "migrate.*migrationsFolder"
    - from: "src/core/db/migrate.ts"
      to: "schema.ts"
      via: "verifyTablesExist() query"
      pattern: "SELECT.*FROM.*tableName"
---

<objective>
Fix database migration retry loop by adding error handling, retry logic, and post-migration verification. This addresses issue M1 (migration retry loop) by ensuring migrations handle partial failures gracefully and verify successful completion.

Purpose: Migrations should recover from transient failures (network issues, Neon API rate limits) without getting stuck in retry loops. Users should see clear error messages and know whether to retry or escalate.

Output: Enhanced migration runner with retry logic, table existence verification, and actionable error messages.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Current state from Phase 01
@src/core/db/migrate.ts
@src/core/db/connection.ts
@src/core/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration retry logic with exponential backoff</name>
  <files>src/core/db/migrate.ts</files>
  <action>
    Enhance runMigrations() function with retry logic:

    1. Add retry configuration (maxRetries=3, baseDelayMs=1000, maxDelayMs=10000)
    2. Wrap migrate() call in retry loop with exponential backoff
    3. Identify retryable errors (network failures, rate limit HTTP 429, Neon API timeouts)
    4. Non-retryable errors (schema conflicts, permission errors) fail immediately
    5. Return retry count and final error in result object

    Retry logic pattern:
    ```typescript
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        await migrate(db, { migrationsFolder });
        return { success: true, attempts: attempt + 1 };
      } catch (err) {
        const error = err as Error;
        if (!isRetryable(error) || attempt === maxRetries) {
          return { success: false, error: error.message, attempts: attempt + 1 };
        }
        const delay = Math.min(baseDelayMs * 2 ** attempt, maxDelayMs);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    ```

    isRetryable() checks for:
    - Network errors (ECONNRESET, ETIMEDOUT)
    - HTTP 429 (rate limit)
    - Neon API timeout errors
    - Does NOT retry schema conflicts, permission errors
  </action>
  <verify>
    1. Run `bun run typecheck` - should pass
    2. Run `bun run lint` - should pass
    3. Test migration with invalid DATABASE_URL - should fail with clear error (not loop)
  </verify>
  <done>
    Migration runner includes retry logic with exponential backoff, distinguishes retryable from non-retryable errors, and returns attempt count in result.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add post-migration table verification</name>
  <files>src/core/db/migrate.ts</files>
  <action>
    Add verifyTablesExist() function to confirm all required tables were created:

    1. Define REQUIRED_TABLES array with all schema tables:
       ["users", "oauth_tokens", "posts", "api_keys", "voice_profiles",
        "edit_history", "post_metrics", "preference_model",
        "strategy_adjustments", "ideas", "series", "trends",
        "weekly_plans", "monitored_accounts", "team_members",
        "invite_codes", "notification_preferences", "notification_log",
        "engagement_opportunities", "engagement_config", "engagement_log",
        "whatsapp_sessions"]

    2. Implement verifyTablesExist(db, requiredTables):
       - For each table, try: SELECT 1 FROM table LIMIT 1
       - Catch errors for missing tables (table not found)
       - Return { success: boolean, missing?: string[] }

    3. Integrate verification into runMigrations():
       - After successful migration, call verifyTablesExist()
       - If tables missing, return error with missing table list
       - Include verification result in return object

    Pattern:
    ```typescript
    async function verifyTablesExist(db: DbClient): Promise<VerificationResult> {
      const missing: string[] = [];
      for (const tableName of REQUIRED_TABLES) {
        try {
          await db.execute(sql`SELECT 1 FROM ${sql.identifier(tableName)} LIMIT 1`);
        } catch {
          missing.push(tableName);
        }
      }
      return { success: missing.length === 0, missing: missing.length > 0 ? missing : undefined };
    }
    ```

    4. Update runMigrations return type to include verification:
       { success, error, attempts, verification }
  </action>
  <verify>
    1. Run `bun run typecheck` - should pass
    2. Run `bun run lint` - should pass
    3. Test with fresh database - should verify all 20 tables exist
    4. Test with incomplete migration - should report missing tables
  </verify>
  <done>
    verifyTablesExist() confirms all 20 required tables exist after migration, returns missing table list for failures, and is integrated into runMigrations() result.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Migration completes successfully on Neon database
2. All 20 schema tables verified as existing post-migration
3. Migration errors show clear actionable messages (no generic failures)
4. Retry loop behavior tested with simulated network failures
5. Verification output shows table-by-table status on demand
</verification>

<success_criteria>
- runMigrations() retries transient failures up to 3 times with exponential backoff
- Non-retryable errors (schema conflicts, permissions) fail immediately with clear messages
- verifyTablesExist() confirms all 20 required tables exist
- Post-migration verification runs automatically after successful migration
- Result object includes success, error, attempts, and verification fields
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-stability/02-01-SUMMARY.md`
</output>
