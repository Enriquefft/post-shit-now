---
phase: 28-thread-publishing-resilience
plan: 02
type: execute
wave: 2
depends_on: [28-01]
files_modified:
  - src/trigger/publish-post.ts
autonomous: true
requirements: [THREAD-02]

must_haves:
  truths:
    - "A post with status 'partially_posted' can be retried via Trigger.dev (not rejected by idempotency check)"
    - "When a partially_posted post is retried, its existing threadProgress metadata is preserved so postThread resumes from checkpoint"
    - "After all Trigger.dev retries exhausted, final state is 'partially_posted' with checkpoint preserved (not 'failed')"
  artifacts:
    - path: "src/trigger/publish-post.ts"
      provides: "Updated idempotency check allowing partially_posted posts"
      contains: "partially_posted"
  key_links:
    - from: "src/trigger/publish-post.ts"
      to: "src/platforms/handlers/x.handler.ts"
      via: "handler.publish() reads threadProgress from post.metadata to resume"
      pattern: "partially_posted"
---

<objective>
Wire partially_posted status into the publish-post orchestrator so thread retries resume from checkpoint instead of being rejected.

Purpose: Without this change, Trigger.dev retries of partially-posted threads are silently skipped by the idempotency check (Pitfall 4 from research). This plan closes the loop so checkpoint-based resume actually works end-to-end.

Output: Modified publish-post.ts that accepts partially_posted posts for retry and preserves checkpoint metadata through the retry flow.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-thread-publishing-resilience/28-01-SUMMARY.md

@src/trigger/publish-post.ts
@src/trigger/publish-helpers.ts

<interfaces>
<!-- Key types and contracts from Plan 01 output -->

From src/core/types/index.ts (after Plan 01):
```typescript
export type PostStatus = "draft" | "scheduled" | "publishing" | "published" | "failed" | "retry" | "partially_posted";
```

From src/trigger/publish-helpers.ts (after Plan 01):
```typescript
export async function markPartiallyPosted(
  db: DbConnection,
  postId: string,
  tweetIds: string[],
  totalTweets: number,
  failReason: string,
): Promise<void>;
```

From src/platforms/handlers/x.handler.ts (after Plan 01):
- postThread reads threadProgress from metadata and resumes from startIndex
- On thread failure with partial progress, throws error (checkpoint already saved by postThread)
- On complete success, returns { status: "published" }
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update idempotency check and failure handling for partially_posted threads</name>
  <files>src/trigger/publish-post.ts</files>
  <action>
Make two targeted changes to `publish-post.ts`:

**Change 1: Update idempotency check (line 89).**

Current code:
```typescript
if (!["scheduled", "retry"].includes(post.status)) {
```

Change to:
```typescript
if (!["scheduled", "retry", "partially_posted"].includes(post.status)) {
```

This allows Trigger.dev retries of partially-posted threads to proceed instead of being silently skipped. The x.handler.ts postThread method reads threadProgress from post.metadata and resumes from the checkpoint.

**Change 2: Import markPartiallyPosted and use it in the failure path.**

Add `markPartiallyPosted` to the existing import from `./publish-helpers.ts`:
```typescript
import { advanceSeriesState, markFailed, markPartiallyPosted, updateBrandPreferenceIfCompany } from "./publish-helpers.ts";
```

In the failure handling section (around line 157, where all platforms failed), check if the post has existing thread checkpoint data. If so, use `markPartiallyPosted` instead of `markFailed` to preserve the checkpoint and set the correct status for future retries:

Replace:
```typescript
// All platforms failed
await markFailed(db, post.id, "all_platforms_failed", { platformStatus });
```

With:
```typescript
// All platforms failed -- check if there's partial thread progress to preserve
const postMeta = post.metadata ?? {};
if (postMeta.threadProgress) {
  // Thread had partial progress -- mark as partially_posted to preserve checkpoint
  const progress = JSON.parse(postMeta.threadProgress as string);
  await markPartiallyPosted(
    db,
    post.id,
    progress.tweetIds ?? [],
    progress.total ?? 0,
    "thread_halted_mid_publish",
  );
} else {
  await markFailed(db, post.id, "all_platforms_failed", { platformStatus });
}
```

This ensures that when a thread fails mid-posting (after x.handler.ts has saved checkpoint data via saveCheckpoint), the orchestrator preserves the `partially_posted` status instead of overwriting it with `failed`. The checkpoint metadata is preserved, so the next Trigger.dev retry can resume from where it left off.

**Important:** Do NOT change the notification dispatch logic below the failure path. Notifications should still fire on final failure (after all Trigger.dev retries exhausted) per user decision. The notification will reference the partially_posted status which communicates the recoverable state.

**Do NOT modify:** The "Mark as publishing" section (line 94-98). When a partially_posted post is retried, it correctly transitions to "publishing" status, and the handler reads the checkpoint from metadata. The metadata is not cleared by the status update because only `status`, `subStatus`, and `updatedAt` are set -- `metadata` is not overwritten.

Wait -- verify this. Check the "Mark as publishing" update (line 95-98):
```typescript
await db
  .update(posts)
  .set({ status: "publishing", subStatus: null, updatedAt: new Date() })
  .where(eq(posts.id, post.id));
```

This update sets only `status`, `subStatus`, and `updatedAt`. It does NOT set `metadata`, so the existing `metadata` (with `threadProgress`) is preserved. This is correct -- no change needed here.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>
- Idempotency check allows "partially_posted" posts through (not skipped with invalid_status)
- Thread checkpoint metadata preserved through retry cycle
- Partially-posted threads use markPartiallyPosted instead of markFailed when threadProgress exists
- "Mark as publishing" step does not overwrite metadata (threadProgress preserved for resume)
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end checkpoint resume flow</name>
  <files>src/trigger/publish-post.ts, src/platforms/handlers/x.handler.ts</files>
  <action>
Verify the complete checkpoint resume flow by tracing the code path. This is a read-only verification task -- no code changes unless a gap is found.

**Trace the flow:**
1. Thread starts posting. After tweet 3 of 7, a network error occurs.
2. x.handler.ts postThread: checkpoint saved (tweetIds=[id1,id2,id3], posted=3, total=7). Error thrown.
3. publish-post.ts: catches error in platform dispatch loop. Post has threadProgress in metadata.
4. publish-post.ts: failure path detects threadProgress, calls markPartiallyPosted. Post status = "partially_posted", metadata.threadProgress preserved.
5. Trigger.dev retries the task (built-in retry with backoff).
6. publish-post.ts: idempotency check sees "partially_posted" -- allows through.
7. publish-post.ts: sets status to "publishing" (metadata NOT overwritten -- threadProgress preserved).
8. x.handler.ts publish(): passes db to postThread.
9. x.handler.ts postThread: parses threadProgress from metadata, sets startIndex=3, tweetIds=[id1,id2,id3].
10. Loop starts at i=3, posts tweets 4-7 using tweetIds[2] (id3) as replyToId for tweet 4.
11. Each new tweet saves checkpoint. On completion, returns published.

**Verify:**
- `grep -n "partially_posted" src/trigger/publish-post.ts` shows it in the idempotency check array AND failure handling
- `grep -n "threadProgress" src/trigger/publish-post.ts` shows the checkpoint detection in failure path
- `grep -n "postThread.*db" src/platforms/handlers/x.handler.ts` confirms db parameter is passed

**If any gap is found during tracing:** Fix it. Possible gaps include:
- The `post.metadata` not being typed as `PostMetadata` in the failure path (it should be -- `PostMetadata` is already imported from schema.ts)
- Missing re-export or type incompatibility

Run `biome check src/trigger/publish-post.ts src/platforms/handlers/x.handler.ts` to ensure formatting is correct.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5 && biome check src/trigger/publish-post.ts src/platforms/handlers/x.handler.ts 2>&1 | tail -5</automated>
  </verify>
  <done>
- End-to-end flow verified: partially_posted -> retry -> publishing -> resume from checkpoint -> published
- No gaps in the checkpoint resume path
- typecheck and biome check pass
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `biome check src/trigger/publish-post.ts` passes
3. `grep -n "partially_posted" src/trigger/publish-post.ts` shows status in idempotency check and failure handling
4. `grep -n "threadProgress" src/trigger/publish-post.ts` shows checkpoint detection in failure path
5. `grep -c "markPartiallyPosted" src/trigger/publish-post.ts` returns >= 1
</verification>

<success_criteria>
- Posts with "partially_posted" status are accepted by the idempotency check (not rejected)
- Failure path preserves checkpoint metadata by using markPartiallyPosted when threadProgress exists
- "Mark as publishing" step does not clear metadata (threadProgress survives)
- Complete flow: partially_posted -> Trigger.dev retry -> idempotency passes -> publishing -> postThread resumes from checkpoint -> published
</success_criteria>

<output>
After completion, create `.planning/phases/28-thread-publishing-resilience/28-02-SUMMARY.md`
</output>
