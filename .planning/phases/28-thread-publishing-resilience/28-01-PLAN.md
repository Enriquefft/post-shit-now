---
phase: 28-thread-publishing-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/types/index.ts
  - src/trigger/publish-helpers.ts
  - src/platforms/handlers/x.handler.ts
autonomous: true
requirements: [THREAD-01, THREAD-03, THREAD-04]

must_haves:
  truths:
    - "After each successful tweet in a thread, the posted tweet ID is persisted to the DB metadata JSONB column"
    - "If a checkpoint DB write fails, it retries up to 3 times before halting the thread"
    - "X API 403 with 'duplicate content' is detected and treated as already-posted, not a failure"
    - "When duplicate is detected, tweet ID recovery is attempted via user timeline lookup"
    - "If tweet ID recovery fails, thread advances without the ID (logs warning, pushes empty string)"
    - "Thread halts on content errors and saves checkpoint before throwing"
  artifacts:
    - path: "src/core/types/index.ts"
      provides: "partially_posted in PostStatus union"
      contains: "partially_posted"
    - path: "src/trigger/publish-helpers.ts"
      provides: "markPartiallyPosted helper function"
      exports: ["markPartiallyPosted"]
    - path: "src/platforms/handlers/x.handler.ts"
      provides: "Checkpoint persistence, Error 187 handling, tweet ID recovery in postThread"
      contains: "retry.onThrow"
  key_links:
    - from: "src/platforms/handlers/x.handler.ts"
      to: "src/trigger/publish-helpers.ts"
      via: "import markPartiallyPosted (not used directly -- checkpoint save is inline)"
      pattern: "retry\\.onThrow"
    - from: "src/platforms/handlers/x.handler.ts"
      to: "src/core/db/schema.ts"
      via: "posts table update for checkpoint"
      pattern: "db\\.update\\(posts\\)"
---

<objective>
Add per-tweet checkpoint persistence, Error 187 duplicate detection, and tweet ID recovery to x.handler.ts thread publishing.

Purpose: Make thread publishing recoverable -- no lost tweet IDs after crashes, no duplicate tweets on retry. This is the core resilience logic.

Output: Modified x.handler.ts with checkpoint saves after each tweet, duplicate error handling, timeline-based ID recovery, and a new markPartiallyPosted helper. PostStatus union updated with "partially_posted".
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-thread-publishing-resilience/28-RESEARCH.md

@src/platforms/handlers/x.handler.ts
@src/core/types/index.ts
@src/trigger/publish-helpers.ts
@src/core/db/schema.ts
@src/platforms/x/types.ts
@src/platforms/x/client.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/platforms/x/types.ts:
```typescript
export class XApiError extends Error {
  public readonly statusCode: number;
  public readonly rateLimit?: RateLimitInfo;
  constructor(statusCode: number, message: string, rateLimit?: RateLimitInfo);
}
export class RateLimitError extends XApiError {
  constructor(rateLimit: RateLimitInfo);
}
```

From src/platforms/x/client.ts:
```typescript
// getTimeline fetches the authenticated user's recent tweets
async getTimeline(params?: { maxResults?: number; tweetFields?: string[] }): Promise<{
  data: Array<{ id: string; text: string; createdAt?: string; ... }>;
  rateLimit: RateLimitInfo;
}>
```

From src/core/db/schema.ts:
```typescript
export interface PostMetadata {
  // ... other fields
  threadProgress?: string; // JSON-stringified checkpoint data
}
// posts table has: metadata: jsonb("metadata").$type<PostMetadata>()
```

From src/core/types/index.ts:
```typescript
export type PostStatus = "draft" | "scheduled" | "publishing" | "published" | "failed" | "retry";
export type PostSubStatus = "retry_1" | "retry_2" | ... | "thread_partial" | "partial_failure" | null;
```

From src/core/types/publisher.ts:
```typescript
export type DbConnection = ...;
export type PostRow = ...;
```

From @trigger.dev/sdk:
```typescript
import { retry, logger, wait } from "@trigger.dev/sdk";
// retry.onThrow(fn, options) -- retries fn up to maxAttempts times on throw
// options: { maxAttempts: number, minTimeoutInMs?: number, factor?: number, randomize?: boolean }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add partially_posted status and markPartiallyPosted helper</name>
  <files>src/core/types/index.ts, src/trigger/publish-helpers.ts</files>
  <action>
1. In `src/core/types/index.ts`, add `"partially_posted"` to the `PostStatus` union type:
   ```typescript
   export type PostStatus = "draft" | "scheduled" | "publishing" | "published" | "failed" | "retry" | "partially_posted";
   ```

2. In `src/trigger/publish-helpers.ts`, add a new exported function `markPartiallyPosted`:
   ```typescript
   export async function markPartiallyPosted(
     db: DbConnection,
     postId: string,
     tweetIds: string[],
     totalTweets: number,
     failReason: string,
   ) {
     const [post] = await db.select().from(posts).where(eq(posts.id, postId)).limit(1);
     const existingMetadata = post?.metadata ?? {};

     await db
       .update(posts)
       .set({
         status: "partially_posted",
         subStatus: "thread_partial",
         failReason,
         updatedAt: new Date(),
         metadata: {
           ...existingMetadata,
           threadProgress: JSON.stringify({
             posted: tweetIds.length,
             total: totalTweets,
             lastPostedId: tweetIds[tweetIds.length - 1] ?? "",
             tweetIds,
           }),
         },
       })
       .where(eq(posts.id, postId));

     logger.warn("Post marked as partially posted", {
       postId,
       posted: tweetIds.length,
       total: totalTweets,
       failReason,
     });
   }
   ```
   Import `logger` from `@trigger.dev/sdk` (already imported). The function uses `DbConnection` (already imported), `posts` and `eq` (already imported).
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>PostStatus union includes "partially_posted". markPartiallyPosted function exported from publish-helpers.ts and compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add checkpoint persistence, Error 187 handling, and tweet ID recovery to postThread</name>
  <files>src/platforms/handlers/x.handler.ts</files>
  <action>
Modify `x.handler.ts` to make thread publishing resilient. This is the core of Phase 28.

**Step 1: Update imports.** Add `retry` to the existing `@trigger.dev/sdk` import. Add `XApiError` to the existing `../x/types.ts` import. The `posts` import from `../../core/db/schema.ts` is already present.

**Step 2: Add isDuplicateError helper** (private function or module-level):
```typescript
function isDuplicateError(error: unknown): boolean {
  if (error instanceof XApiError && error.statusCode === 403) {
    return error.message.toLowerCase().includes("duplicate content");
  }
  return false;
}
```

**Step 3: Add recoverTweetId helper** (module-level async function):
```typescript
async function recoverTweetId(
  client: XClient,
  tweetText: string,
): Promise<string | null> {
  try {
    const timeline = await client.getTimeline({ maxResults: 10 });
    // Normalize for t.co URL differences: compare trimmed text without URLs
    const normalize = (s: string) => s.replace(/https?:\/\/\S+/g, "").trim();
    const normalizedInput = normalize(tweetText);
    const match = timeline.data.find((t) => normalize(t.text) === normalizedInput);
    return match?.id ?? null;
  } catch {
    return null; // Recovery is best-effort
  }
}
```

**Step 4: Add saveCheckpoint helper** (module-level async function wrapping retry.onThrow):
```typescript
async function saveCheckpoint(
  db: DbConnection,
  postId: string,
  tweetIds: string[],
  totalTweets: number,
  existingMetadata: Record<string, unknown>,
) {
  await retry.onThrow(
    async () => {
      await db
        .update(posts)
        .set({
          subStatus: "thread_partial",
          updatedAt: new Date(),
          metadata: {
            ...existingMetadata,
            threadProgress: JSON.stringify({
              posted: tweetIds.length,
              total: totalTweets,
              lastPostedId: tweetIds[tweetIds.length - 1] ?? "",
              tweetIds: [...tweetIds],
            }),
          },
        })
        .where(eq(posts.id, postId));
    },
    { maxAttempts: 3, minTimeoutInMs: 500, factor: 2, randomize: false },
  );
}
```
Per user decision: if retry.onThrow exhausts all 3 attempts, it throws -- halting the thread. Checkpoint failure is never swallowed.

**Step 5: Modify postThread signature** to accept `db` parameter:
```typescript
private async postThread(
  client: XClient,
  tweets: string[],
  mediaIds: string[] | undefined,
  metadata: Record<string, unknown> | null,
  postId: string,
  db: DbConnection,  // NEW parameter
): Promise<PlatformPublishResult>
```

**Step 6: Update the postThread call site** in `publish()` (around line 151) to pass `db`:
```typescript
return await this.postThread(client, tweets, mediaIds, metadata as Record<string, unknown>, postId, db);
```

**Step 7: Rewrite the postThread loop** to add checkpoint persistence and Error 187 handling:
```typescript
private async postThread(
  client: XClient,
  tweets: string[],
  mediaIds: string[] | undefined,
  metadata: Record<string, unknown> | null,
  postId: string,
  db: DbConnection,
): Promise<PlatformPublishResult> {
  const threadProgress = metadata?.threadProgress
    ? threadProgressSchema.parse(JSON.parse(metadata.threadProgress as string))
    : undefined;
  const startIndex = threadProgress?.posted ?? 0;
  const tweetIds = threadProgress?.tweetIds ?? [];
  const existingMetadata = metadata ?? {};
  const mediaIdsPerTweet = tweets.map((_, i) => (i === 0 ? mediaIds : undefined));

  for (let i = startIndex; i < tweets.length; i++) {
    const tweetText = tweets[i];
    if (!tweetText) continue;

    let tweetId: string;

    try {
      // retry.onThrow retries the tweet API call 3 times inline for network errors
      // (per user decision: "Network error mid-thread: retry the specific tweet 2-3 times inline,
      // then halt and let Trigger.dev retry")
      // Rate limit and duplicate errors are NOT retried -- they are wrapped with a
      // __skipRetry marker to skip retry.onThrow's retry logic and reach the outer catch.
      const result = await retry.onThrow(
        async () => {
          try {
            return await client.createTweet({
              text: tweetText,
              replyToId: i > 0 ? tweetIds[i - 1] : undefined,
              mediaIds: mediaIdsPerTweet[i],
            });
          } catch (innerError) {
            // Let rate limit and duplicate errors skip retry by wrapping in __skipRetry marker
            if (innerError instanceof RateLimitError || isDuplicateError(innerError)) {
              const abort = new Error("abort_retry");
              (abort as any).cause = innerError;
              (abort as any).__skipRetry = true;
              throw abort;
            }
            throw innerError; // Network/other errors: retry.onThrow will retry
          }
        },
        { maxAttempts: 3, minTimeoutInMs: 1000, factor: 2 },
      );
      tweetId = result.id;
    } catch (tweetError) {
      // Unwrap skip-retry wrapper to get the original error
      const actualError = (tweetError as any)?.__skipRetry ? (tweetError as any).cause : tweetError;

      // Rate limit: wait for cooldown, retry same tweet (per user decision)
      if (actualError instanceof RateLimitError && actualError.rateLimit) {
        logger.warn("X rate limited during thread, waiting", {
          postId,
          tweetIndex: i,
          resetAt: actualError.rateLimit.resetAt.toISOString(),
        });
        await wait.until({ date: actualError.rateLimit.resetAt });
        i--;
        continue;
      }

      // Error 187 equivalent: duplicate content (per user decision -- react only, no proactive check)
      if (isDuplicateError(actualError)) {
        const recoveredId = await recoverTweetId(client, tweetText);
        if (recoveredId) {
          tweetId = recoveredId;
          logger.info("Recovered duplicate tweet ID", { postId, tweetIndex: i, recoveredId });
        } else {
          // Advance without ID per user decision
          tweetId = "";
          logger.warn("Duplicate detected but could not recover tweet ID", { postId, tweetIndex: i });
        }
      } else {
        // Network error (after 3 inline retries exhausted) or content error:
        // checkpoint what we have, then throw for Trigger.dev task-level retry
        if (tweetIds.length > 0) {
          await saveCheckpoint(db, postId, tweetIds, tweets.length, existingMetadata);
          logger.info("Thread checkpoint saved before error", { postId, posted: tweetIds.length, total: tweets.length });
        }
        throw actualError;
      }
    }

    tweetIds.push(tweetId);

    // Persist checkpoint after each successful tweet (THREAD-01)
    // retry.onThrow retries 2-3 times; if exhausted, throws and halts thread (THREAD-03)
    await saveCheckpoint(db, postId, tweetIds, tweets.length, existingMetadata);
    logger.info("Thread checkpoint saved", { postId, tweetIndex: i, posted: tweetIds.length, total: tweets.length });
  }

  return { platform: "x", status: "published", externalPostId: tweetIds[0] };
}
```

**Key design notes:**
- `retry.onThrow` is from `@trigger.dev/sdk` -- do NOT hand-roll retry loops. It wraps BOTH the tweet API call (inline retry for network errors) AND the checkpoint DB write (retry on DB failure).
- The tweet API `retry.onThrow` catches network errors inline (3 attempts, 1s base backoff, factor 2). If all 3 fail, the error falls to the outer catch block which saves checkpoint and throws for Trigger.dev task-level retry.
- Rate limit and duplicate errors are NOT retried by the inner `retry.onThrow` -- they are wrapped in a `__skipRetry` marker error inside the callback so they propagate immediately to the outer catch for specialized handling. The outer catch unwraps the marker to get the original error. This prevents wasting retry attempts on errors that need domain-specific handling (wait-and-loop for rate limits, ID recovery for duplicates).
- `wait.until` from `@trigger.dev/sdk` checkpoints the task (free compute while waiting).
- The `isDuplicateError` checks for X API v2 format (HTTP 403 + "duplicate content" in body text). Do NOT check for legacy error code 187.
- `recoverTweetId` uses normalized text comparison to handle t.co URL rewriting.
- The `tweetIds` array may contain empty strings for unrecoverable duplicates. Use `posted` count (not `tweetIds.length`) is NOT needed here because we always push to tweetIds on every iteration, so `tweetIds.length` always equals the posted count. The `lastPostedId` field tracks the last known tweet ID for reply chain continuity.
- When `i > 0` and `tweetIds[i - 1]` is empty string (from unrecoverable duplicate), the reply chain may break for that tweet. This is acceptable per user decision -- advancing without ID is better than halting.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -10</automated>
  </verify>
  <done>
- client.createTweet() wrapped in retry.onThrow with 3 attempts for inline network error retry (per user decision)
- Rate limit and duplicate errors skip inline retry via __skipRetry marker pattern
- postThread persists checkpoint to DB after each successful tweet via retry.onThrow (THREAD-01, THREAD-03)
- X API 403 "duplicate content" detected via isDuplicateError and treated as success (THREAD-04)
- Tweet ID recovery attempted via user timeline lookup; advances without ID if recovery fails
- Checkpoint saved before throwing on content/network errors (after inline retries exhausted)
- Rate limit mid-thread waits for cooldown and retries same tweet
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes (no new type errors)
2. `biome check src/platforms/handlers/x.handler.ts src/core/types/index.ts src/trigger/publish-helpers.ts` passes
3. `grep -n "partially_posted" src/core/types/index.ts` shows the new status in PostStatus union
4. `grep -n "retry.onThrow" src/platforms/handlers/x.handler.ts` shows checkpoint retry wrapper
5. `grep -n "duplicate content" src/platforms/handlers/x.handler.ts` shows Error 187 detection
6. `grep -n "markPartiallyPosted" src/trigger/publish-helpers.ts` shows the new helper
</verification>

<success_criteria>
- PostStatus union includes "partially_posted"
- markPartiallyPosted helper exported from publish-helpers.ts
- postThread saves checkpoint to DB after each successful tweet using retry.onThrow
- Checkpoint DB write retries up to 3 times; failure halts thread (never swallowed)
- X API 403 "duplicate content" detected and treated as already-posted
- Tweet ID recovery attempted via timeline lookup; advances without ID on failure
- Rate limit mid-thread triggers wait.until, then retries same tweet
- Content/network errors save checkpoint before throwing
</success_criteria>

<output>
After completion, create `.planning/phases/28-thread-publishing-resilience/28-01-SUMMARY.md`
</output>
