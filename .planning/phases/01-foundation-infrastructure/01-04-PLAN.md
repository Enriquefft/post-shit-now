---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 3
depends_on: [01-01, 01-02, 01-03]
files_modified:
  - src/core/utils/env.ts
  - src/cli/setup-keys.ts
autonomous: true
requirements: [C4]

must_haves:
  truths:
    - "Provider keys are validated via API calls before storage"
    - "Trigger.dev, Perplexity, Anthropic keys all validated"
    - "Validation failures show clear error and suggestion"
    - "Validation framework is extensible to new providers"
  artifacts:
    - path: "src/core/utils/env.ts"
      provides: "Provider key validation framework"
      exports: ["validateProviderKey", "VALIDATORS"]
      min_lines: 80
    - path: "src/cli/setup-keys.ts"
      provides: "Key setup with validation"
      contains: "validateProviderKey"
  key_links:
    - from: "src/cli/setup-keys.ts"
      to: "src/core/utils/env.ts"
      via: "validateProviderKey call"
      pattern: "validateProviderKey"
    - from: "src/core/utils/env.ts"
      to: "provider APIs"
      via: "fetch calls to validate keys"
      pattern: "fetch.*api"
---

<objective>
Extend API key validation framework to all provider keys (Trigger.dev, Perplexity, Anthropic, etc.) with provider-specific API validation endpoints. This completes C4 (API key validation) per CONTEXT.md decision to apply validation to all providers.

Purpose: CONTEXT.md specifies "Apply to all provider keys - extend validation framework to Trigger.dev, Perplexity, Anthropic, etc., not just Neon". Create extensible validation framework for all providers.

Output: VALIDATORS object mapping provider names to validation functions, validateProviderKey utility function, integration into setup-keys.ts.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@src/core/utils/env.ts
@src/cli/setup-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Add provider key validation framework to env.ts</name>
  <files>src/core/utils/env.ts</files>
  <action>
Add VALIDATORS mapping and validateProviderKey function to src/core/utils/env.ts:

```typescript
export interface ValidationResult {
  valid: boolean;
  error?: string;
  suggestion?: string;
  warning?: string;
}

// Provider-specific validation functions
async function validateTriggerDevApiKey(apiKey: string): Promise<ValidationResult> {
  // Prefix check: Trigger.dev keys start with "tr_dev_" or "tr_prod_"
  if (!apiKey.startsWith("tr_dev_") && !apiKey.startsWith("tr_prod_")) {
    return {
      valid: false,
      error: "Invalid Trigger.dev API key format",
      suggestion: "Trigger.dev API keys start with 'tr_dev_' (development) or 'tr_prod_' (production)."
    };
  }

  // API validation: list projects to verify key works
  try {
    const response = await fetch("https://api.trigger.dev/v1/projects", {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
      },
    });

    if (response.status === 401) {
      return {
        valid: false,
        error: "Trigger.dev API key invalid or expired",
        suggestion: "Regenerate API key from Trigger.dev Dashboard."
      };
    }

    // Success: can list projects
    return { valid: true };
  } catch (error) {
    return {
      valid: true, // Assume valid if can't verify
      warning: `Could not validate Trigger.dev key: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

async function validatePerplexityApiKey(apiKey: string): Promise<ValidationResult> {
  // Prefix check: Perplexity keys start with "pplx-"
  if (!apiKey.startsWith("pplx-")) {
    return {
      valid: false,
      error: "Invalid Perplexity API key format",
      suggestion: "Perplexity API keys start with 'pplx-'."
    };
  }

  // API validation: make a minimal API call
  try {
    const response = await fetch("https://api.perplexity.ai/models", {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
      },
    });

    if (response.status === 401) {
      return {
        valid: false,
        error: "Perplexity API key invalid or expired",
        suggestion: "Regenerate API key from Perplexity Settings."
      };
    }

    // Success: can list models
    return { valid: true };
  } catch (error) {
    return {
      valid: true,
      warning: `Could not validate Perplexity key: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

async function validateAnthropicApiKey(apiKey: string): Promise<ValidationResult> {
  // Prefix check: Anthropic keys start with "sk-ant-"
  if (!apiKey.startsWith("sk-ant-")) {
    return {
      valid: false,
      error: "Invalid Anthropic API key format",
      suggestion: "Anthropic API keys start with 'sk-ant-'."
    };
  }

  // API validation: list models
  try {
    const response = await fetch("https://api.anthropic.com/v1/models", {
      headers: {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01",
      },
    });

    if (response.status === 401) {
      return {
        valid: false,
        error: "Anthropic API key invalid or expired",
        suggestion: "Regenerate API key from Anthropic Console."
      };
    }

    // Success: can list models
    return { valid: true };
  } catch (error) {
    return {
      valid: true,
      warning: `Could not validate Anthropic key: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

// Map of provider names to validation functions
const VALIDATORS: Record<string, (key: string) => Promise<ValidationResult>> = {
  neon: validateNeonApiKey,
  trigger: validateTriggerDevApiKey,
  perplexity: validatePerplexityApiKey,
  anthropic: validateAnthropicApiKey,
  // Add more validators as needed
};

/**
 * Validate a provider API key using appropriate validator.
 * Returns valid=true if no validator exists for provider (graceful degradation).
 */
export async function validateProviderKey(
  service: string,
  apiKey: string
): Promise<ValidationResult> {
  const validator = VALIDATORS[service];
  if (!validator) {
    // No validator defined for this provider - assume valid
    return { valid: true };
  }
  return await validator(apiKey);
}
```

This follows CONTEXT.md decisions: "Validate via API call" and "Apply to all provider keys".
</action>
  <verify>
Run: `grep -A 10 "const VALIDATORS" src/core/utils/env.ts` to verify validators mapping exists.
</verify>
  <done>
VALIDATORS mapping and validateProviderKey function exist in src/core/utils/env.ts with validators for Neon, Trigger.dev, Perplexity, and Anthropic.
</done>
</task>

<task type="auto">
  <name>Integrate provider key validation into setup-keys.ts</name>
  <files>src/cli/setup-keys.ts</files>
  <action>
Update writeProviderKey function in src/cli/setup-keys.ts to validate before saving:

```typescript
import { validateProviderKey } from "../core/utils/env.ts";

export async function writeProviderKey(
  hubId: string,
  service: string,
  value: string,
  configDir = "config",
): Promise<SetupResult> {
  const hubEnv = await loadHubEnv(configDir);
  if (!hubEnv.success) {
    return { step: "keys", status: "error", message: hubEnv.error };
  }

  // NEW: Validate provider key before saving
  const validation = await validateProviderKey(service, value);
  if (!validation.valid) {
    return {
      step: "keys",
      status: "error",
      message: `${service} API key validation failed: ${validation.error}`,
      data: {
        error: validation.error,
        suggestion: validation.suggestion,
      },
    };
  }

  if (validation.warning) {
    console.warn(`Warning: ${validation.warning}`);
  }

  const db = createHubConnection(hubEnv.data.databaseUrl);

  try {
    await setApiKey(db, hubId, service, service, value);
    return {
      step: "keys",
      status: "success",
      message: `${service} key saved to database for hub ${hubId}`,
    };
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    return {
      step: "keys",
      status: "error",
      message: `Failed to save ${service} key: ${message}`,
    };
  }
}
```

Also update writeKey function (for config/keys.env keys) to validate NEON_API_KEY:
```typescript
export async function writeKey(
  key: string,
  value: string,
  configDir = "config",
): Promise<SetupResult> {
  // Validate NEON_API_KEY specifically
  if (key === "NEON_API_KEY") {
    const validation = await validateProviderKey("neon", value);
    if (!validation.valid) {
      return {
        step: "keys",
        status: "error",
        message: `NEON_API_KEY validation failed: ${validation.error}`,
        data: {
          error: validation.error,
          suggestion: validation.suggestion,
        },
      };
    }
  }

  const filePath = join(configDir, "keys.env");
  const file = Bun.file(filePath);

  let existingKeys: Record<string, string> = {};
  if (await file.exists()) {
    const content = await file.text();
    existingKeys = parseEnvFile(content);
  }

  existingKeys[key] = value;

  const lines = Object.entries(existingKeys).map(([k, v]) => `${k}=${v}`);
  await Bun.write(filePath, `${lines.join("\n")}\n`);

  return {
    step: "keys",
    status: "success",
    message: `${key} saved to ${filePath}`,
  };
}
```
</action>
  <verify>
Run: `grep -A 5 "validateProviderKey" src/cli/setup-keys.ts` to verify validation calls exist.
</verify>
  <done>
setup-keys.ts validates provider keys before saving, with clear error messages for invalid keys.
</done>
</task>

</tasks>

<verification>
After completing all tasks, verify:
1. VALIDATORS mapping exists in env.ts with validators for neon, trigger, perplexity, anthropic
2. Each validator has prefix check and API validation
3. validateProviderKey function routes to correct validator
4. writeProviderKey validates before saving to database
5. writeKey validates NEON_API_KEY before saving to keys.env
6. Error messages include both error and suggestion
</verification>

<success_criteria>
- All provider keys (Neon, Trigger.dev, Perplexity, Anthropic) validated before storage
- Validation framework is extensible (add new validator to VALIDATORS object)
- Invalid keys rejected with clear error messages and suggestions
- Prefix checks provide immediate feedback
- API validation catches expired/incorrect keys
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
