---
phase: 15-database-stability-recovery-p1
plan: 04
type: execute
wave: 2
depends_on: [15-01]
files_modified: [src/cli/setup-reset.ts, src/cli/setup.ts]
autonomous: true
requirements: [M14]

must_haves:
  truths:
    - "/psn:setup reset command requires --db, --files, or --all flag (no default scope)"
    - "Reset shows summary of what would be deleted before executing"
    - "User confirmation required before destructive actions with prompt 'This will delete X. Continue? (y/n)'"
    - "Reset with --db flag deletes drizzle/meta directory"
    - "Reset with --files flag deletes .hubs directory (all hub connection files)"
  artifacts:
    - path: "src/cli/setup-reset.ts"
      provides: "Setup reset and recovery command"
      exports: ["setupReset"]
      min_lines: 80
    - path: "src/cli/setup.ts"
      provides: "Reset subcommand routing"
      min_lines: 10
  key_links:
    - from: "src/cli/setup.ts"
      to: "src/cli/setup-reset.ts"
      via: "function import"
      pattern: "import.*setupReset.*from.*setup-reset"
    - from: "src/cli/setup-reset.ts"
      to: "node:fs/promises"
      via: "file operations"
      pattern: "import.*rm.*stat.*readdir.*from.*node:fs/promises"
---

<objective>
Add /psn:setup reset command for cleanup and recovery from failed setup. Reset command supports selective scope via flags (--db, --files, --all), shows summary before execution, and requires explicit user confirmation. No automatic backup — reset is destructive by design (user must backup manually if needed).

Purpose: Enable clean recovery from partial setup state or failed migrations.
Output: setupReset() function and /psn:setup reset subcommand with selective deletion, summary display, and confirmation prompt.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-database-stability-recovery-p1/15-CONTEXT.md
@.planning/phases/15-database-stability-recovery-p1/15-RESEARCH.md

@/home/hybridz/Projects/post-shit-now/src/cli/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Create setup reset function with selective scope</name>
  <files>src/cli/setup-reset.ts</files>
  <action>
    Create src/cli/setup-reset.ts with setupReset() function:

    ```
    import { readdir, rm, stat } from "node:fs/promises";
    import { join } from "node:path";

    interface ResetResult {
      action: string;
      description: string;
      path?: string;
    }

    export async function setupReset(
      configDir = "config",
      projectRoot = ".",
      scope: { db: boolean; files: boolean },
      dryRun = false,
    ): Promise<{ results: ResetResult[]; error?: string }> {

      const results: ResetResult[] = [];

      // Default behavior: require explicit scope (user decision)
      if (!scope.db && !scope.files) {
        return {
          results: [],
          error: "No scope specified. Use --db, --files, or --all flags."
        };
      }

      // --db scope: delete drizzle/meta directory
      if (scope.db) {
        const metaDir = join(projectRoot, "drizzle", "meta");
        try {
          const metaStat = await stat(metaDir);
          if (metaStat.isDirectory()) {
            if (dryRun) {
              results.push({
                action: "[DRY RUN] Delete",
                description: "drizzle/meta directory (migration state)",
                path: metaDir
              });
            } else {
              await rm(metaDir, { recursive: true });
              results.push({
                action: "Deleted",
                description: "drizzle/meta directory (migration state)",
                path: metaDir
              });
            }
          }
        } catch {
          results.push({
            action: "Skipped",
            description: "drizzle/meta directory not found (already clean)"
          });
        }
      }

      // --files scope: delete .hubs directory
      if (scope.files) {
        const hubsDir = join(projectRoot, ".hubs");
        try {
          const hubsStat = await stat(hubsDir);
          if (hubsStat.isDirectory()) {
            const entries = await readdir(hubsDir);
            const fileCount = entries.filter(e => e.endsWith(".json")).length;

            if (dryRun) {
              results.push({
                action: "[DRY RUN] Delete",
                description: `.hubs directory (${fileCount} hub connection files)`,
                path: hubsDir
              });
            } else {
              await rm(hubsDir, { recursive: true });
              results.push({
                action: "Deleted",
                description: `.hubs directory (${fileCount} hub connection files)`,
                path: hubsDir
              });
            }
          }
        } catch {
          results.push({
            action: "Skipped",
            description: ".hubs directory not found (already clean)"
          });
        }
      }

      return { results };
    }
    ```

    Key decisions per CONTEXT.md:
    - Selective reset via flags (--db, --files, --all)
    - Require explicit scope (no default behavior)
    - Show summary before execution
    - Require confirmation: "This will delete X. Continue? (y/n)"
    - No backup (destructive by design)
  </action>
  <verify>
    1. Check setup-reset.ts exists and exports setupReset function
    2. Test dry-run: setupReset(".", ".", { db: true, files: false }, true) should return "[DRY RUN] Delete" results
    3. Test scope validation: setupReset(".", ".", { db: false, files: false }, false) should return error "No scope specified"
    4. Run lint: bun run lint — should pass
  </verify>
  <done>
    setupReset() function supports selective scope (--db, --files, --all), shows dry-run summary, and deletes drizzle/meta and .hubs directories.
  </done>
</task>

<task type="auto">
  <name>Add reset subcommand to setup.ts</name>
  <files>src/cli/setup.ts</files>
  <action>
    In src/cli/setup.ts, add reset subcommand handler:

    1. Import setupReset function at top:
       ```
       import { setupReset } from "./setup-reset.ts";
       ```

    2. Add reset case to runSetupSubcommand() switch statement:

       ```
       case "reset": {
         const flags = parseResetFlags(params);

         // Show summary first (dry-run)
         const summary = await setupReset(configDir, projectRoot, flags, true);
         if (summary.error) {
           return {
             steps: [{ step: "reset", status: "error", message: summary.error }],
             validation: null,
             completed: false
           };
         }

         // Display summary to user
         const summaryOutput = [];
         summaryOutput.push("\nReset Summary:");
         summaryOutput.push("=".repeat(50));
         for (const result of summary.results) {
           summaryOutput.push(`${result.action}: ${result.description}`);
           if (result.path) summaryOutput.push(`  Path: ${result.path}`);
         }

         // Return summary with need_input status for user confirmation
         return {
           steps: [{
             step: "reset",
             status: "need_input",
             message: "Reset pending confirmation",
             data: {
               summary: summaryOutput.join("\n"),
               flags: flags,
               instructions: "Type 'y' to confirm or 'n' to cancel"
             }
           }],
           validation: null,
           completed: false
         };
       }
       ```

    3. Add parseResetFlags() helper function:

       ```
       function parseResetFlags(params: Record<string, string>): { db: boolean; files: boolean } {
         const db = params.db === "true" || params.all === "true";
         const files = params.files === "true" || params.all === "true";
         return { db, files };
       }
       ```

    4. Update CLI argument parsing in parseCliArgs() to handle reset flags:

       Add after line 600 (after keys handling):
       ```
       // Handle reset flags
       if (subcommand === "reset") {
         if (flagArgs.includes("--db")) params.db = "true";
         if (flagArgs.includes("--files")) params.files = "true";
         if (flagArgs.includes("--all")) params.all = "true";
       }
       ```

    Note: Actual confirmation prompt is handled by Claude in slash command context. This implementation returns summary with need_input status, allowing the orchestrator to prompt the user and re-invoke with confirmation.

    Key decisions per CONTEXT.md:
    - Show summary first (dry-run mode)
    - Return need_input status for confirmation (not interactive stdin here)
    - Support --db, --files, --all flags
    - Explicit scope required (error if no flags)
  </action>
  <verify>
    1. Check runSetupSubcommand() has reset case that calls setupReset with dryRun=true
    2. Verify parseResetFlags() parses --db, --files, --all flags
    3. Test: /psn:setup reset without flags returns error "No scope specified"
    4. Test: /psn:setup reset --db returns summary with need_input status
    5. Run lint: bun run lint — should pass
  </verify>
  <done>
    /psn:setup reset subcommand supports --db, --files, --all flags, shows dry-run summary, and returns need_input status for user confirmation.
  </done>
</task>

</tasks>

<verification>
1. setup-reset.ts exists with setupReset() function
2. setupReset requires explicit scope (--db, --files, or --all flag)
3. setupReset shows dry-run summary before execution
4. setup.ts has reset case that calls setupReset with dryRun=true
5. Reset returns need_input status with summary and confirmation instructions
</verification>

<success_criteria>
1. /psn:setup reset without flags returns error requiring scope specification
2. /psn:setup reset --db shows summary of drizzle/meta deletion
3. /psn:setup reset --files shows summary of .hubs directory deletion
4. /psn:setup reset --all shows summary of both directories
5. Reset returns need_input status with confirmation prompt instructions
</success_criteria>

<output>
After completion, create `.planning/phases/15-database-stability-recovery-p1/15-04-SUMMARY.md`
</output>
