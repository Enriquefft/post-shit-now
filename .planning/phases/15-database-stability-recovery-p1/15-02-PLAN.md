---
phase: 15-database-stability-recovery-p1
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/core/utils/nanoid.ts, src/core/utils/env.ts]
autonomous: true
requirements: [M2, C12]

must_haves:
  truths:
    - "Missing hubId in legacy hub.env files triggers auto-generation during migration"
    - "Generated hubId uses nanoid-style format (12 chars, URL-friendly)"
    - "Auto-generated hubId written to .hubs/*.json only on successful migration"
    - "Migration failure does NOT write hubId (prevents partial state corruption)"
  artifacts:
    - path: "src/core/utils/nanoid.ts"
      provides: "Nanoid-style ID generation using Node.js crypto"
      exports: ["nanoid"]
      min_lines: 20
    - path: "src/core/utils/env.ts"
      provides: "Hub migration with nanoid hubId generation"
      min_lines: 100
  key_links:
    - from: "src/cli/setup-db.ts"
      to: "src/core/utils/nanoid.ts"
      via: "function import"
      pattern: "import.*nanoid.*from.*nanoid"
    - from: "src/core/utils/env.ts"
      to: "src/core/utils/nanoid.ts"
      via: "function import"
      pattern: "import.*nanoid"
    - from: "src/core/utils/env.ts"
      to: "src/team/types.ts"
      via: "HubConnection schema validation"
      pattern: "HubConnectionSchema\\.parse"
---

<objective>
Add nanoid-style hubId generation for legacy hub.env files during migration. Personal Hub files migrated from config/hub.env to .hubs/personal.json lack hubId field. This plan creates nanoid utility and updates migration to auto-generate hubId when missing. Generated ID only written on successful migration completion.

Purpose: Ensure consistent hubId across all hub connection files without manual intervention.
Output: nanoid utility function and hubId auto-generation in migratePersonalHubToHubsDir().
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-database-stability-recovery-p1/15-CONTEXT.md
@.planning/phases/15-database-stability-recovery-p1/15-RESEARCH.md

@/home/hybridz/Projects/post-shit-now/src/core/utils/env.ts
@/home/hybridz/Projects/post-shit-now/src/team/types.ts
@/home/hybridz/Projects/post-shit-now/src/cli/setup-db.ts
@/home/hybridz/Projects/post-shit-now/src/team/hub.ts
</context>

<tasks>

<task type="auto">
  <name>Create nanoid utility function</name>
  <files>src/core/utils/nanoid.ts</files>
  <action>
    Create src/core/utils/nanoid.ts with nanoid-style ID generation:

    ```
    import { randomBytes } from "node:crypto";

    const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    const DEFAULT_LENGTH = 12;

    /**
     * Generate a nanoid-style ID using Node.js crypto.
     * Shorter than UUID, URL-friendly, cryptographically secure.
     * Collision probability at 12 chars: ~1 in 3.2e21 (statistically impossible)
     *
     * @param size - Length of ID to generate (default: 12)
     * @returns URL-friendly random string
     */
    export function nanoid(size = DEFAULT_LENGTH): string {
      const id = new Uint8Array(size);
      randomBytes.fillSync(id);

      let result = "";
      while (size--) {
        result += ALPHABET[id[size] & 63];
      }
      return result;
    }
    ```

    Key decisions per CONTEXT.md:
    - Use crypto.randomBytes() (native, no nanoid dependency)
    - 12-character length with 62-symbol alphabet (collision probability: 1 in 3.2e21)
    - URL-friendly (alphanumeric, no special characters)
  </action>
  <verify>
    1. Check src/core/utils/nanoid.ts exists and exports nanoid function
    2. Verify function returns 12-character alphanumeric string: bun run -e 'import { nanoid } from "./src/core/utils/nanoid.ts"; console.log(nanoid()); console.log(nanoid().length)'
    3. Run lint: bun run lint â€” should pass
  </verify>
  <done>
    nanoid() function generates 12-character URL-friendly IDs using Node.js crypto API.
  </done>
</task>

<task type="auto">
  <name>Update hub migration to auto-generate hubId</name>
  <files>src/core/utils/env.ts</files>
  <action>
    In src/core/utils/env.ts, update migratePersonalHubToHubsDir() function to auto-generate hubId:

    1. Import nanoid utility:
       ```
       import { nanoid } from "./nanoid.ts";
       ```

    2. In migratePersonalHubToHubsDir(), after reading config/hub.env:

       Find the section that creates connection object. Before creating the connection, add hubId generation:

       ```
       // Generate hubId if missing (legacy hub.env files)
       const hubId = `hub_${nanoid()}`;

       const connection = {
         hubId,  // Add this field
         slug: "personal",
         displayName: "Personal Hub",
         databaseUrl: hubEnvResult.data.databaseUrl,
         triggerProjectId: hubEnvResult.data.triggerProjectRef || "",
         role: "admin" as const,
         joinedAt: new Date().toISOString(),
       };
       ```

    3. After validation with HubConnectionSchema, write to .hubs/personal.json:

       The file write should already exist from Phase 1 migration. Ensure it includes the hubId field.

    4. Add error handling for migration failures:

       Before writing .hubs/personal.json, check if migration succeeded. If validation fails, do NOT write hubId (prevents partial state corruption):

       ```
       // Validate connection object before writing
       const validated = HubConnectionSchema.parse(connection);

       // Only write if validation passes (prevents partial state)
       await Bun.write(personalHubPath, JSON.stringify(validated, null, 2));
       ```

    5. Return hubId in result (for verification):

       Update return value to include generated hubId:
       ```
       return {
         success: true,
         data: { hubId, migratedFrom: "config/hub.env" }
       };
       ```

    Key decisions per CONTEXT.md:
    - Auto-generate hubId when missing from legacy files
    - Write generated hubId to .hubs/*.json only on successful migration completion
    - Collision handling: ignore case (nanoid collision is astronomically unlikely)
  </action>
  <verify>
    1. Check migratePersonalHubToHubsDir() generates hubId using nanoid()
    2. Verify hubId format: starts with "hub_" followed by 12 alphanumeric chars
    3. Validate HubConnectionSchema.parse() called before file write
    4. Test migration flow: create dummy config/hub.env without hubId, run migration, check .hubs/personal.json has hubId field
  </verify>
  <done>
    migratePersonalHubToHubsDir() auto-generates nanoid-style hubId for legacy hub.env files. HubId written to .hubs/personal.json only on successful migration completion.
  </done>
</task>

</tasks>

<verification>
1. nanoid utility exists and generates 12-character alphanumeric strings
2. migratePersonalHubToHubsDir() generates hubId when missing from hub.env
3. HubId validation occurs before writing to .hubs/personal.json
4. Migration failure prevents hubId write (prevents partial state)
5. Generated hubId format: "hub_" + 12 chars (e.g., "hub_k3M8x7nV9pZ")
</verification>

<success_criteria>
1. Legacy hub.env files without hubId get auto-generated hubId during migration
2. Generated hubId passes HubConnectionSchema validation
3. Migration failures don't write partial hubId to .hubs/personal.json
4. HubId format consistent with nanoid-style (12 alphanumeric chars)
5. setup-db.ts uses updated migration that generates hubId
</success_criteria>

<output>
After completion, create `.planning/phases/15-database-stability-recovery-p1/15-02-SUMMARY.md`
</output>
