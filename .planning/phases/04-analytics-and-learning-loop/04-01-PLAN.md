---
phase: 04-analytics-and-learning-loop
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/db/schema.ts
  - src/platforms/x/client.ts
  - src/platforms/x/types.ts
  - src/analytics/scoring.ts
  - src/analytics/scoring.test.ts
  - src/analytics/types.ts
autonomous: true
requirements: [ANLYT-05, LEARN-01]

must_haves:
  truths:
    - "Each published post can receive a composite engagement score weighted saves > shares > comments > likes"
    - "Each post can receive an engagement rate (per impression) as a separate metric"
    - "XClient can batch-fetch tweet metrics from X API v2"
    - "Raw metrics are stored alongside computed scores for future recalculation"
  artifacts:
    - path: "src/core/db/schema.ts"
      provides: "postMetrics, preferenceModel, strategyAdjustments tables with RLS"
      contains: "postMetrics"
    - path: "src/analytics/scoring.ts"
      provides: "computeEngagementScore, computeEngagementRate functions"
      exports: ["computeEngagementScore", "computeEngagementRate"]
    - path: "src/analytics/scoring.test.ts"
      provides: "Tests for scoring functions"
      contains: "computeEngagementScore"
    - path: "src/analytics/types.ts"
      provides: "Analytics Zod schemas and types"
      exports: ["TweetPublicMetricsSchema", "TweetWithMetricsSchema"]
    - path: "src/platforms/x/client.ts"
      provides: "getTweets and getMe methods on XClient"
      contains: "getTweets"
    - path: "src/platforms/x/types.ts"
      provides: "TweetsLookupResponseSchema, UserLookupResponseSchema"
      contains: "TweetsLookupResponseSchema"
  key_links:
    - from: "src/analytics/scoring.ts"
      to: "src/analytics/types.ts"
      via: "import TweetPublicMetrics type"
      pattern: "import.*TweetPublicMetrics"
    - from: "src/platforms/x/client.ts"
      to: "src/platforms/x/types.ts"
      via: "import TweetsLookupResponseSchema for validation"
      pattern: "TweetsLookupResponseSchema"
---

<objective>
Add the analytics foundation: new DB tables for metrics/preferences/adjustments, extend XClient with GET methods for tweet metrics, and build the engagement scoring engine with TDD.

Purpose: Everything in Phase 4 depends on these schemas, the scoring engine, and the ability to fetch metrics from X. This is the data layer foundation.
Output: New DB tables (migration-ready), XClient GET methods, tested scoring functions, analytics type system.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-analytics-and-learning-loop/04-RESEARCH.md
@src/core/db/schema.ts
@src/platforms/x/client.ts
@src/platforms/x/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schema tables + X API types + XClient GET methods</name>
  <files>
    src/core/db/schema.ts
    src/platforms/x/types.ts
    src/platforms/x/client.ts
    src/analytics/types.ts
  </files>
  <action>
**DB Schema (src/core/db/schema.ts):** Add three new tables following the exact RLS pattern used by existing tables (pgPolicy with `current_setting('app.current_user_id')`):

1. `postMetrics` table: id (uuid PK), userId (text), postId (uuid), platform (text), externalPostId (text), raw metrics columns (impressionCount, likeCount, retweetCount, quoteCount, replyCount, bookmarkCount as integers default 0; urlLinkClicks, userProfileClicks as nullable integers), computed scores (engagementScore integer default 0, engagementRateBps integer default 0 — store rate as basis points to avoid floating point), context columns (postFormat text nullable, postTopic text nullable, postPillar text nullable), collectedAt and createdAt timestamps.

2. `preferenceModel` table: id (uuid PK), userId (text, unique), engagement learnings as jsonb (topFormats, topPillars, bestPostingTimes, hookPatterns), edit learnings as jsonb (commonEditPatterns, avgEditRatio as integer), fatiguedTopics as jsonb array, lockedSettings as jsonb array, followerHistory as jsonb array, updatedAt and createdAt timestamps.

3. `strategyAdjustments` table: id (uuid PK), userId (text), adjustmentType (text), field (text), oldValue (jsonb), newValue (jsonb), reason (text), evidence (jsonb string array), tier (text: "auto" | "approval"), status (text default "pending": "pending" | "applied" | "approved" | "rejected"), appliedAt (nullable timestamp), createdAt timestamp.

All three tables get RLS policies identical to the existing pattern.

**X API Types (src/platforms/x/types.ts):** Add Zod schemas for X API v2 GET responses:
- `TweetPublicMetricsSchema`: z.object with retweet_count, reply_count, like_count, quote_count, bookmark_count, impression_count (all z.number())
- `TweetNonPublicMetricsSchema`: z.object with url_link_clicks and user_profile_clicks (both z.number().optional())
- `TweetWithMetricsSchema`: z.object with id (string), text (string), public_metrics, non_public_metrics (optional)
- `TweetsLookupResponseSchema`: z.object with data array of TweetWithMetrics
- `UserPublicMetricsSchema`: z.object with followers_count, following_count, tweet_count, listed_count (all z.number())
- `UserLookupResponseSchema`: z.object with data containing id, name, username, public_metrics
- Export all types via z.infer

**Analytics Types (src/analytics/types.ts):** Re-export the metric types from x/types.ts for use by analytics modules. Also define:
- `EngagementScoreResult` interface: { score: number; rate: number; rateBps: number }
- `PostMetricsSummary` interface with post context + scores for use in review/reports

**XClient Extension (src/platforms/x/client.ts):** Add two new methods using the existing `request()` private method:

1. `getTweets(ids: string[], fields?: { tweetFields?: string[] })`: Builds URL params with `ids` joined by comma, optional `tweet.fields` param. Calls `this.request()` with GET method and `TweetsLookupResponseSchema`. Chunk IDs into batches of 100 internally — return aggregated results. Handle empty ids array (return empty data).

2. `getMe(fields?: { userFields?: string[] })`: Builds URL params for `user.fields`. Calls `this.request()` with GET to `/2/users/me` and `UserLookupResponseSchema`.

Note: The existing `request()` method is private. It already handles auth headers, rate limits, and Zod validation. The new GET methods just need to build the right URL and pass the right schema.
  </action>
  <verify>
    Run `npx drizzle-kit generate` to confirm schema changes produce a valid migration.
    Run `npx tsc --noEmit` to confirm all types are correct.
  </verify>
  <done>
    Three new DB tables defined with RLS. XClient has getTweets() and getMe() methods. All X API response schemas defined and exported. Analytics types module exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Engagement scoring engine (TDD: RED then GREEN)</name>
  <files>
    src/analytics/scoring.test.ts
    src/analytics/scoring.ts
  </files>
  <action>
**RED phase — write failing tests first (src/analytics/scoring.test.ts):**

Test `computeEngagementScore`:
- Basic case: {bookmark_count: 2, retweet_count: 3, quote_count: 1, reply_count: 5, like_count: 10} should return 2*4 + 3*3 + 1*3 + 5*2 + 10*1 = 8+9+3+10+10 = 40
- All zeros returns 0
- High saves dominance: {bookmark_count: 100, others: 0} returns 400
- Verify weights: saves(4) > shares(3) > comments(2) > likes(1) per user decision

Test `computeEngagementRate`:
- Normal case: 50 total engagements / 1000 impressions = 0.05 (5%)
- Zero impressions returns 0 (no division by zero)
- Very low impressions (< 100): still computes but returns rate

Test `computeEngagementRateBps`:
- Same as rate but multiplied by 10000 and rounded to integer (basis points)
- 50/1000 = 500 bps

Test `aggregateThreadMetrics`:
- Given array of TweetPublicMetrics (one per tweet in thread), should:
  - Sum absolute counts (likes, retweets, etc.)
  - Use first tweet's impression_count as primary for rate calculation
  - Return single aggregated TweetPublicMetrics

**GREEN phase — implement (src/analytics/scoring.ts):**

```
const ENGAGEMENT_WEIGHTS = {
  bookmark_count: 4,
  retweet_count: 3,
  quote_count: 3,
  reply_count: 2,
  like_count: 1,
} as const;
```

Implement:
- `computeEngagementScore(metrics: TweetPublicMetrics): number` — weighted sum
- `computeEngagementRate(metrics: TweetPublicMetrics): number` — total engagements / impressions, guard against zero
- `computeEngagementRateBps(metrics: TweetPublicMetrics): number` — rate * 10000, rounded
- `aggregateThreadMetrics(threadMetrics: TweetPublicMetrics[]): TweetPublicMetrics` — sum all fields, use first tweet's impressions
- Export `ENGAGEMENT_WEIGHTS` for transparency

All functions are pure — no DB, no I/O. Import types from `../analytics/types.ts`.
  </action>
  <verify>
    Run `npx vitest run src/analytics/scoring.test.ts` — all tests pass.
    Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
    Scoring functions pass all tests. Weights match user decision (saves > shares > comments > likes). Thread metrics aggregate correctly. Zero-impression edge case handled.
  </done>
</task>

</tasks>

<verification>
- `npx drizzle-kit generate` produces a migration file for the 3 new tables
- `npx vitest run src/analytics/scoring.test.ts` passes all scoring tests
- `npx tsc --noEmit` compiles without errors
- XClient.getTweets and XClient.getMe methods exist with correct signatures
</verification>

<success_criteria>
- Three new DB tables (postMetrics, preferenceModel, strategyAdjustments) with RLS policies
- XClient extended with getTweets() (batch, chunked at 100) and getMe() methods
- Engagement scoring engine tested: composite score with correct weights, rate with zero-guard, thread aggregation
- All analytics types defined and exported
</success_criteria>

<output>
After completion, create `.planning/phases/04-analytics-and-learning-loop/04-01-SUMMARY.md`
</output>
