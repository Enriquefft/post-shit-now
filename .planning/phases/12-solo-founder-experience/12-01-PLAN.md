---
phase: 12-solo-founder-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/voice/types.ts
  - src/voice/profile.ts
  - src/voice/entity-profiles.ts
  - src/core/db/schema.ts
  - drizzle/migrations/meta/_journal.json
autonomous: true
requirements:
  - VOICE-11

must_haves:
  truths:
    - "VoiceProfile schema includes entitySlug, entityDisplayName, entityDescription, maturityLevel fields"
    - "voice_profiles table exists in Hub DB with profileData jsonb column storing full VoiceProfile"
    - "loadProfileByEntity() loads entity-specific profile from DB or falls back to YAML"
    - "listEntities() returns all entities for a user with lastUsedAt for picker ordering"
    - "Entity slug auto-generated from display name via slugify helper"
    - "Slug collisions handled by appending -2, -3, etc."
  artifacts:
    - path: "src/voice/types.ts"
      provides: "Extended VoiceProfile schema with entity fields and maturity level"
      changes: "Add entitySlug, entityDisplayName, entityDescription, maturityLevel fields"
    - path: "src/core/db/schema.ts"
      provides: "voice_profiles table for entity-scoped profile storage"
      changes: "Add voiceProfiles table with entity columns and unique index"
    - path: "src/voice/entity-profiles.ts"
      provides: "Entity CRUD operations, slug generation, picker data"
      exports: ["loadProfileByEntity", "listEntities", "createEntity", "updateEntity", "deleteEntity", "slugify"]
  key_links:
    - from: "src/voice/entity-profiles.ts"
      to: "src/core/db/schema.ts"
      via: "import { voiceProfiles } from '../core/db/schema'"
      pattern: "voiceProfiles.*entitySlug.*profileData"
    - from: "src/voice/profile.ts"
      to: "src/voice/entity-profiles.ts"
      via: "import { loadProfileByEntity } from './entity-profiles'"
      pattern: "loadProfileByEntity.*entitySlug"
    - from: "src/core/db/schema.ts"
      to: "src/voice/types.ts"
      via: "VoiceProfile type in jsonb column"
      pattern: "\\$type<VoiceProfile>"
---

<objective>
Add entity-scoped voice profiles that allow solo founders to maintain distinct voices per project without Company Hub overhead. Entities are stored in Personal Hub DB with entity_slug distinguishing profiles.

Purpose: Enable multi-project voice management for solo founders (VOICE-11).
Output: Extended VoiceProfile schema, voice_profiles DB table, entity CRUD operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/12-solo-founder-experience/12-CONTEXT.md
@.planning/phases/12-solo-founder-experience/12-RESEARCH.md
@src/voice/types.ts
@src/voice/profile.ts
@src/core/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Extend VoiceProfile schema with entity fields</name>
  <files>src/voice/types.ts</files>
  <action>
Extend the VoiceProfile schema in src/voice/types.ts to support entity-scoped profiles:

1. Add maturity level type:
   export type MaturityLevel = "never_posted" | "sporadic" | "consistent" | "very_active";

2. Add entity fields to voiceProfileSchema:
   - entitySlug: z.string().optional() - URL-safe identifier (e.g., "psn-founder")
   - entityDisplayName: z.string().optional() - Human-readable name (e.g., "PSN Founder")
   - entityDescription: z.string().optional() - Shown in picker
   - maturityLevel: z.enum(["never_posted", "sporadic", "consistent", "very_active"]).optional()

3. Update createDefaultProfile() and createBlankSlateProfile() to initialize new fields as undefined.

4. Export MaturityLevel type for use in interview and planning modules.
  </action>
  <verify>
grep -n "entitySlug" src/voice/types.ts returns at least 1
grep -n "entityDisplayName" src/voice/types.ts returns at least 1
grep -n "maturityLevel" src/voice/types.ts returns at least 1
grep -n "MaturityLevel" src/voice/types.ts returns at least 1
  </verify>
  <done>
VoiceProfile schema includes entitySlug, entityDisplayName, entityDescription, maturityLevel
MaturityLevel type exported for reuse
Default profile factories initialize new fields correctly
  </done>
</task>

<task type="auto">
  <name>Add voice_profiles table to schema</name>
  <files>src/core/db/schema.ts, drizzle/migrations/meta/_journal.json</files>
  <action>
Add voice_profiles table to src/core/db/schema.ts following existing patterns:

1. Import VoiceProfile type:
   import type { VoiceProfile } from "../voice/types";

2. Create voiceProfiles table:
   export const voiceProfiles = pgTable(
     "voice_profiles",
     {
       id: uuid("id").defaultRandom().primaryKey(),
       userId: text("user_id").notNull(),
       entitySlug: text("entity_slug").notNull(),
       entityDisplayName: text("entity_display_name"),
       entityDescription: text("entity_description"),
       lastUsedAt: timestamp("last_used_at", { withTimezone: true }),
       profileData: jsonb("profile_data").$type<VoiceProfile>().notNull(),
       createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
       updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
     },
     (table) => [
       uniqueIndex("voice_profiles_user_entity_idx").on(table.userId, table.entitySlug),
       pgPolicy("voice_profiles_isolation", {
         as: "permissive",
         to: hubUser,
         for: "all",
         using: sql`${table.userId} = current_setting('app.current_user_id')`,
         withCheck: sql`${table.userId} = current_setting('app.current_user_id')`,
       }),
     ],
   );

3. Generate migration:
   bunx drizzle-kit generate

4. Update _journal.json if needed.
  </action>
  <verify>
grep -n "voiceProfiles" src/core/db/schema.ts returns at least 2
grep -n "voice_profiles_user_entity_idx" src/core/db/schema.ts returns 1
ls -la drizzle/migrations/ | tail -3
  </verify>
  <done>
voice_profiles table defined with RLS policy
Unique index on (userId, entitySlug) for O(1) lookups
Migration file generated
  </done>
</task>

<task type="auto">
  <name>Create entity-profiles.ts with CRUD operations</name>
  <files>src/voice/entity-profiles.ts</files>
  <action>
Create src/voice/entity-profiles.ts with entity management functions:

1. Slugify helper:
   export function slugify(name: string): string {
     return name
       .toLowerCase()
       .trim()
       .replace(/[^a-z0-9]+/g, "-")
       .replace(/^-+|-+$/g, "");
   }

2. EntitySummary interface:
   export interface EntitySummary {
     slug: string;
     displayName: string | null;
     description: string | null;
     lastUsedAt: Date | null;
   }

3. listEntities(db, userId): Promise<EntitySummary[]>
   - Query voice_profiles where userId = userId
   - Order by lastUsedAt DESC (most recent first)
   - Return EntitySummary array for picker

4. loadProfileByEntity(db, userId, entitySlug): Promise<VoiceProfile | null>
   - Query voice_profiles where userId AND entitySlug
   - If found: update lastUsedAt to now(), return profileData
   - If not found: return null (caller falls back to YAML or creates new)

5. createEntity(db, userId, displayName, description?): Promise<string>
   - Generate slug from displayName via slugify()
   - Handle collisions: query existing slugs, append -2, -3, etc.
   - Create VoiceProfile with entity fields populated
   - Insert into voice_profiles
   - Return entitySlug

6. updateEntity(db, userId, entitySlug, updates): Promise<void>
   - Update profileData and entityDisplayName/entityDescription
   - Update updatedAt timestamp

7. deleteEntity(db, userId, entitySlug): Promise<void>
   - Delete row from voice_profiles
   - Hard delete (entities are lightweight, recreate if needed)

8. saveEntityToYaml(profile: VoiceProfile): Promise<void>
   - Export profile to content/voice/{entitySlug}.yaml for backup
   - Follow existing atomic write pattern from profile.ts
  </action>
  <verify>
grep -n "export.*function.*listEntities" src/voice/entity-profiles.ts returns 1
grep -n "export.*function.*loadProfileByEntity" src/voice/entity-profiles.ts returns 1
grep -n "export.*function.*createEntity" src/voice/entity-profiles.ts returns 1
grep -n "export.*function.*updateEntity" src/voice/entity-profiles.ts returns 1
grep -n "export.*function.*deleteEntity" src/voice/entity-profiles.ts returns 1
grep -n "export.*function.*slugify" src/voice/entity-profiles.ts returns 1
  </verify>
  <done>
Entity CRUD operations implemented
Slug generation with collision handling
YAML export for backup
All functions use Drizzle ORM patterns
  </done>
</task>

<task type="auto">
  <name>Add entity selection to profile loading</name>
  <files>src/voice/profile.ts</files>
  <action>
Update src/voice/profile.ts to support entity-scoped profile loading:

1. Add import:
   import { loadProfileByEntity, type EntitySummary } from "./entity-profiles";

2. Add loadProfile function overload for entity selection:
   export async function loadProfile(options?: {
     profilePath?: string;
     entitySlug?: string;
     db?: Database;
     userId?: string;
   }): Promise<VoiceProfile>

3. Logic:
   - If db and userId and entitySlug provided: try loadProfileByEntity()
   - If found in DB: return it
   - If not found and entitySlug provided: throw error "Entity not found: {entitySlug}"
   - If no entitySlug: fall back to YAML file loading (existing behavior)

4. Export EntitySummary from profile.ts for convenience:
   export type { EntitySummary } from "./entity-profiles";
  </action>
  <verify>
grep -n "entitySlug" src/voice/profile.ts returns at least 2
grep -n "loadProfileByEntity" src/voice/profile.ts returns 1
  </verify>
  <done>
loadProfile() supports both YAML file and DB entity loading
Entity selection flow integrated into profile module
Backward compatible with existing YAML-only loading
  </done>
</task>

</tasks>

<verification>
1. VoiceProfile schema includes all 4 entity fields (entitySlug, displayName, description, maturityLevel)
2. voice_profiles table exists with RLS and unique index on (userId, entitySlug)
3. listEntities() returns entities ordered by lastUsedAt
4. loadProfileByEntity() updates lastUsedAt on access
5. createEntity() handles slug collisions by appending numbers
6. YAML export creates file at content/voice/{slug}.yaml
7. All functions follow existing Drizzle ORM patterns
</verification>

<success_criteria>
Entity-scoped voice profiles can be created, stored, and retrieved from DB.
Multiple entities per user supported without Company Hub.
Slug collision handling prevents duplicate entity identifiers.
YAML backup/export preserves profiles outside DB.
</success_criteria>

<output>
After completion, create `.planning/phases/12-solo-founder-experience/12-01-SUMMARY.md`
</output>
