# Phase 27: X OAuth Callback Server - Research

**Researched:** 2026-02-27
**Domain:** OAuth 2.0 callback server, Bun HTTP, CLI UX
**Confidence:** HIGH

## Summary

This phase replaces the manual copy-paste OAuth authorization code flow with an automatic localhost callback server. The existing `setup-x-oauth.ts` currently returns a `need_input` status with a URL for the user to open and manually paste the code. The new flow spins up a temporary HTTP server on `127.0.0.1:18923`, auto-opens the browser, captures the callback, and feeds the code directly into the token exchange.

The implementation is straightforward: a standalone callback server module using `Bun.serve` (not Node's `http` module -- this is a Bun project), integration into the existing `setupXOAuth()` flow, and a manual fallback when the port is unavailable. The `arctic` library already handles state generation, PKCE, and token exchange -- the callback server just needs to capture the `code` and `state` query parameters.

**Primary recommendation:** Use `Bun.serve` for the callback server (native, zero-dependency, project-consistent). Keep the module generic enough for future LinkedIn/Instagram/TikTok reuse (OAUTH-05 in backlog).

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Fixed port 127.0.0.1:18923 (not configurable, not dynamic)
- Callback URL constant lives in `src/platforms/x/oauth.ts` (single source of truth)
- Standalone module at `src/cli/oauth-callback-server.ts`
- No new dependencies -- use built-in HTTP server
- Success page: minimal HTML with "Authorization complete! You can close this tab."
- 2-minute timeout before fallback to manual code entry
- CSRF validation via state parameter string comparison
- Browser auto-opens via `open` (macOS) / `xdg-open` (Linux) / `start` (Windows)
- Testing deferred to Phase 29

### Claude's Discretion
- Internal module structure and type definitions
- Error message exact wording (must be user-friendly and actionable per CONTEXT.md)
- Promise/async patterns for server lifecycle
- How to detect headless/SSH environments for browser-open fallback

### Deferred Ideas (OUT OF SCOPE)
- LinkedIn/Instagram/TikTok OAuth callbacks (OAUTH-05, v1.4+)
- Migration help for existing setups
- Dynamic port selection
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| OAUTH-01 | Callback server captures authorization code automatically via localhost (127.0.0.1:18923) | Bun.serve API for HTTP server, URL parsing for query params |
| OAUTH-02 | Callback URL is defined in a single constant used by all code paths | Move constant from `setup-x-oauth.ts` to `src/platforms/x/oauth.ts`, import everywhere |
| OAUTH-03 | OAuth state parameter is validated to prevent CSRF attacks | State already generated by `arctic`'s `generateState()`, simple string comparison in callback handler |
| OAUTH-04 | Callback server falls back to manual code entry if port is unavailable | Catch EADDRINUSE from Bun.serve, degrade to current `need_input` flow |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `Bun.serve` | built-in | HTTP callback server | Native Bun API, zero deps, project uses Bun exclusively |
| `arctic` | ^3.7.0 | OAuth state/PKCE/token exchange | Already in use for X OAuth (`generateState`, `generateCodeVerifier`, `Twitter` client) |
| `ora` | ^9.3.0 | Terminal spinner during wait | Already in use in `src/cli/utils/progress.ts` |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `node:child_process` | built-in | Open browser via `xdg-open`/`open` | Bun supports `node:child_process` for spawning system commands |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `Bun.serve` | `node:http` | CONTEXT.md says "Node built-in http", but this is a Bun project with `bun-types`. Bun.serve is simpler, faster, and idiomatic. Bun does support `node:http` for compat, but Bun.serve is preferred. |
| `open` npm package | `child_process.exec` with platform detection | No new deps; `open` package would add a dependency for something achievable in ~10 lines |

**Installation:**
```bash
# No new packages needed -- all built-in or already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── cli/
│   ├── oauth-callback-server.ts  # NEW: Generic OAuth callback server
│   └── setup-x-oauth.ts          # MODIFIED: Integrates callback server
├── platforms/
│   └── x/
│       └── oauth.ts              # MODIFIED: Add X_CALLBACK_URL constant
```

### Pattern 1: Promise-Based Ephemeral Server
**What:** Server starts, resolves a promise on first valid callback, then shuts down.
**When to use:** CLI tools that need a one-shot HTTP listener for OAuth callbacks.
**Example:**
```typescript
// Source: Bun.serve docs + OAuth callback pattern
interface CallbackResult {
  code: string;
  state: string;
}

interface CallbackError {
  error: "timeout" | "state_mismatch" | "port_unavailable" | "missing_params";
  message: string;
}

type CallbackOutcome =
  | { ok: true; result: CallbackResult }
  | { ok: false; error: CallbackError };

function startCallbackServer(
  expectedState: string,
  options: { port: number; hostname: string; timeoutMs: number }
): Promise<CallbackOutcome> {
  return new Promise((resolve) => {
    let server: ReturnType<typeof Bun.serve>;

    const timeout = setTimeout(() => {
      server.stop(true);
      resolve({ ok: false, error: { error: "timeout", message: "..." } });
    }, options.timeoutMs);

    try {
      server = Bun.serve({
        port: options.port,
        hostname: options.hostname,
        fetch(req) {
          const url = new URL(req.url);
          if (url.pathname !== "/callback") {
            return new Response("", { status: 404 });
          }
          const code = url.searchParams.get("code");
          const state = url.searchParams.get("state");

          if (!code || !state) {
            return new Response("Missing parameters", { status: 400 });
          }
          if (state !== expectedState) {
            return new Response("Invalid state", { status: 403 });
          }

          // Respond FIRST, then resolve + cleanup
          clearTimeout(timeout);
          // Use queueMicrotask to ensure response is sent before shutdown
          queueMicrotask(() => {
            server.stop();
            resolve({ ok: true, result: { code, state } });
          });

          return new Response(SUCCESS_HTML, {
            headers: { "Content-Type": "text/html" },
          });
        },
      });
    } catch (err) {
      clearTimeout(timeout);
      // EADDRINUSE or other bind error
      resolve({ ok: false, error: { error: "port_unavailable", message: "..." } });
    }
  });
}
```

### Pattern 2: Platform-Agnostic Browser Opening
**What:** Cross-platform browser opening without external deps.
**When to use:** CLI tools that need to open URLs in the default browser.
**Example:**
```typescript
import { exec } from "node:child_process";

function openBrowser(url: string): boolean {
  const platform = process.platform;
  try {
    if (platform === "darwin") {
      exec(`open "${url}"`);
    } else if (platform === "win32") {
      exec(`start "" "${url}"`);
    } else {
      exec(`xdg-open "${url}"`);
    }
    return true;
  } catch {
    return false;
  }
}
```

### Pattern 3: Headless/SSH Detection
**What:** Detect if running in a headless environment where browser can't open.
**When to use:** Before attempting to auto-open browser.
**Example:**
```typescript
function canOpenBrowser(): boolean {
  // SSH session detection
  if (process.env.SSH_CLIENT || process.env.SSH_TTY) return false;
  // No display on Linux
  if (process.platform === "linux" && !process.env.DISPLAY && !process.env.WAYLAND_DISPLAY) return false;
  return true;
}
```

### Anti-Patterns to Avoid
- **Starting server before generating auth URL:** The state parameter must be generated first, then passed to the server. Server needs `expectedState` at creation time.
- **Not responding before shutdown:** If you call `server.stop()` before the Response is sent, the browser gets a connection reset. Always respond first, then clean up asynchronously.
- **Blocking on readline during server wait:** The server runs on Bun's event loop. Don't block with `readline-sync` while waiting for the callback. Use async patterns (promises + setTimeout).

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| State generation | Custom random string | `arctic`'s `generateState()` | Already used, cryptographically secure |
| PKCE verifier | Custom base64url | `arctic`'s `generateCodeVerifier()` | Already used, handles padding correctly |
| Token exchange | Raw HTTP POST | `arctic`'s `client.validateAuthorizationCode()` | Already used, handles error formats |
| URL parsing | String splitting | `new URL(req.url)` + `searchParams` | Web standard, handles edge cases |

**Key insight:** The `arctic` library already handles all OAuth cryptography. The callback server is purely a transport mechanism -- capture the code from the redirect and feed it to the existing `exchangeCode()` function.

## Common Pitfalls

### Pitfall 1: X Rejects 127.0.0.1 Callback URL
**What goes wrong:** X Developer Portal may reject `http://127.0.0.1:18923/callback` during app registration or the OAuth flow returns an error.
**Why it happens:** X has historically been inconsistent about accepting IP addresses vs hostnames for callback URLs. Some reports indicate `127.0.0.1` works, others say it doesn't.
**How to avoid:** The CONTEXT.md decision is to use `127.0.0.1` (not `localhost`). If X rejects it, the user must update their Developer Portal settings. The validation step in section 4 of CONTEXT.md covers this.
**Warning signs:** OAuth redirect fails with "Callback URL not approved" or similar error from X.

### Pitfall 2: Response Not Sent Before Server Shutdown
**What goes wrong:** Browser shows "connection reset" instead of success page.
**Why it happens:** `server.stop()` closes the socket before the Response body is fully transmitted.
**How to avoid:** Use `queueMicrotask()` or `setTimeout(..., 0)` to defer server shutdown after the response handler returns. Bun.serve's `stop()` without `true` allows in-flight responses to complete.
**Warning signs:** Success page intermittently fails to display.

### Pitfall 3: Timeout Timer Not Cleared
**What goes wrong:** Timeout fires after successful callback, causing double resolution or unexpected side effects.
**Why it happens:** Forgetting to `clearTimeout()` in the success path.
**How to avoid:** Always clear the timeout timer when the callback is received successfully.
**Warning signs:** Console errors or warnings appearing after successful authorization.

### Pitfall 4: Port Already in Use
**What goes wrong:** `Bun.serve` throws on startup because another process holds port 18923.
**Why it happens:** Previous crashed server, another dev tool, or user service on that port.
**How to avoid:** Wrap `Bun.serve()` in try/catch, check for EADDRINUSE, and fall back to manual code entry (OAUTH-04).
**Warning signs:** Server fails to start silently; user waits for a callback that never comes.

### Pitfall 5: Bun.serve Error Handling Differences
**What goes wrong:** Assuming Bun.serve throws like Node's `http.createServer().listen()` for port conflicts.
**Why it happens:** Bun.serve may handle errors differently than Node's http module.
**How to avoid:** Test port-in-use scenario explicitly. Bun.serve does throw synchronously if the port is unavailable, so try/catch around the `Bun.serve()` call works.
**Warning signs:** Uncaught exceptions on server start.

## Code Examples

### Current Flow (to be replaced)
```typescript
// Source: src/cli/setup-x-oauth.ts (lines 101-121)
// Current: Returns need_input with auth URL for manual paste
const { url, state: _state, codeVerifier } = generateAuthUrl(client);
return {
  step: "x-oauth",
  status: "need_input",
  message: "X authorization required",
  data: {
    authUrl: url,
    state: _state,
    codeVerifier,
    instructions: "Open the URL... paste the authorization code...",
  },
};
```

### New Flow (target)
```typescript
// New: Auto-capture via callback server
const { url, state, codeVerifier } = generateAuthUrl(client);

// Try automatic capture
const outcome = await captureOAuthCallback(state, {
  authUrl: url,
  timeoutMs: 120_000,
});

if (outcome.ok) {
  // Proceed directly to token exchange
  return completeXOAuth(configDir, outcome.result.code, outcome.result.state, codeVerifier);
}

// Fallback: manual code entry
return {
  step: "x-oauth",
  status: "need_input",
  message: `${outcome.error.message}. Paste the authorization code from the redirect URL:`,
  data: { authUrl: url, state, codeVerifier },
};
```

### Callback URL Constant (OAUTH-02)
```typescript
// Source: src/platforms/x/oauth.ts (to be added)
/** Single source of truth for X OAuth callback URL. Used by setup flow and callback server. */
export const X_CALLBACK_URL = "http://127.0.0.1:18923/callback";
export const OAUTH_CALLBACK_PORT = 18923;
export const OAUTH_CALLBACK_HOSTNAME = "127.0.0.1";
```

### Success HTML Page
```typescript
const SUCCESS_HTML = `<!DOCTYPE html>
<html>
<head><title>Authorization Complete</title></head>
<body style="font-family:system-ui;display:flex;justify-content:center;align-items:center;height:100vh;margin:0">
<div style="text-align:center">
<h1>Authorization complete!</h1>
<p>You can close this tab.</p>
<script>setTimeout(()=>window.close(),3000)</script>
</div>
</body>
</html>`;
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual code paste from redirect URL | Localhost callback server captures automatically | Standard practice (RFC 8252) | Eliminates main UX friction point |
| `node:http` for servers | `Bun.serve` in Bun projects | Bun 1.0+ (2023) | Simpler API, better performance, native |
| `open` npm package for browser | Platform-detected `exec` calls | Always an option | Zero additional dependencies |

**Deprecated/outdated:**
- CONTEXT.md mentions "Node built-in http module" but this project runs exclusively on Bun. `Bun.serve` is the correct choice. Bun does support `node:http` via compatibility layer, but `Bun.serve` is idiomatic and simpler.

## Open Questions

1. **X Developer Portal callback URL validation**
   - What we know: CONTEXT.md says to query X API to verify the registered callback URL matches. X API v2 does not have a public endpoint to fetch app callback URLs programmatically.
   - What's unclear: Whether such an API endpoint exists or if this verification must be done by attempting the OAuth flow and catching the redirect mismatch error.
   - Recommendation: Skip programmatic validation. Instead, if the OAuth redirect fails (wrong callback URL), catch the error and show the user the expected callback URL to configure. This is simpler and equally effective.

2. **Bun.serve error type for EADDRINUSE**
   - What we know: Bun.serve throws synchronously when port is unavailable.
   - What's unclear: Exact error type/code Bun uses (may differ from Node's `EADDRINUSE`).
   - Recommendation: Catch any error from `Bun.serve()` constructor, check for port-related message, and fall back to manual flow. The exact error code is implementation detail.

3. **window.close() browser behavior**
   - What we know: `window.close()` only works for windows opened by JavaScript (not user-initiated tabs). The 3-second auto-close may not work in all browsers.
   - What's unclear: Whether most browsers will honor it for OAuth redirects.
   - Recommendation: Keep the auto-close attempt but don't rely on it -- the "You can close this tab" message is the real UX.

## Sources

### Primary (HIGH confidence)
- Bun.serve docs (https://bun.com/docs/runtime/http/server) - Server API, port config, stop method, fetch handler
- Existing codebase: `src/platforms/x/oauth.ts` - Arctic library usage, state/PKCE generation
- Existing codebase: `src/cli/setup-x-oauth.ts` - Current OAuth flow, setupXOAuth/completeXOAuth signatures

### Secondary (MEDIUM confidence)
- X Developer Platform OAuth 2.0 PKCE docs (https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code) - PKCE requirements, callback URL rules
- RFC 8252 (OAuth 2.0 for Native Apps) - Localhost callback pattern is standard practice
- X Developer Community discussion on 127.0.0.1 callback URLs - Mixed reports on acceptance

### Tertiary (LOW confidence)
- X Developer Portal programmatic callback URL verification - No evidence this API exists; CONTEXT.md assumption may need adjustment

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools already in the project, Bun.serve well-documented
- Architecture: HIGH - Pattern is well-established (RFC 8252), codebase structure clear
- Pitfalls: MEDIUM - X's callback URL acceptance of 127.0.0.1 has mixed reports; Bun.serve error handling for port conflicts not empirically verified

**Research date:** 2026-02-27
**Valid until:** 2026-03-27 (stable domain, unlikely to change)
