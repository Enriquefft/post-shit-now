---
phase: 27-x-oauth-callback-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/platforms/x/oauth.ts
  - src/cli/oauth-callback-server.ts
autonomous: true
requirements:
  - OAUTH-01
  - OAUTH-02
  - OAUTH-03

must_haves:
  truths:
    - "Callback server captures authorization code from browser redirect on 127.0.0.1:18923"
    - "Callback URL is defined as a single exported constant in src/platforms/x/oauth.ts"
    - "OAuth state parameter is validated on callback to prevent CSRF"
    - "Server shuts down after first valid callback"
    - "Server times out after 2 minutes and resolves with error"
  artifacts:
    - path: "src/platforms/x/oauth.ts"
      provides: "X_CALLBACK_URL, OAUTH_CALLBACK_PORT, OAUTH_CALLBACK_HOSTNAME constants"
      exports: ["X_CALLBACK_URL", "OAUTH_CALLBACK_PORT", "OAUTH_CALLBACK_HOSTNAME"]
    - path: "src/cli/oauth-callback-server.ts"
      provides: "Promise-based ephemeral OAuth callback server"
      exports: ["startCallbackServer", "openBrowser", "canOpenBrowser"]
      min_lines: 60
  key_links:
    - from: "src/cli/oauth-callback-server.ts"
      to: "src/platforms/x/oauth.ts"
      via: "imports OAUTH_CALLBACK_PORT, OAUTH_CALLBACK_HOSTNAME"
      pattern: "import.*OAUTH_CALLBACK"
---

<objective>
Create the OAuth callback server module and define callback URL constants as single source of truth.

Purpose: Enables automatic authorization code capture via localhost instead of manual copy-paste. The callback server is a standalone module reusable for future platform OAuth flows (LinkedIn/Instagram/TikTok in OAUTH-05 backlog).

Output: Two files -- constants in `src/platforms/x/oauth.ts` and the callback server at `src/cli/oauth-callback-server.ts`.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-x-oauth-callback-server/27-CONTEXT.md
@.planning/phases/27-x-oauth-callback-server/27-RESEARCH.md

@src/platforms/x/oauth.ts
@src/cli/setup-x-oauth.ts

<interfaces>
<!-- Key types and contracts the executor needs -->

From src/platforms/x/oauth.ts:
```typescript
import { generateCodeVerifier, generateState, Twitter } from "arctic";
import type { XOAuthConfig } from "../../core/types/index.ts";

export function createXOAuthClient(config: XOAuthConfig): Twitter;
export function generateAuthUrl(client: Twitter): { url: string; state: string; codeVerifier: string };
export function exchangeCode(client: Twitter, code: string, codeVerifier: string): Promise<{ accessToken: string; refreshToken: string; expiresAt: Date }>;
export function refreshAccessToken(client: Twitter, refreshToken: string): Promise<{ accessToken: string; refreshToken: string; expiresAt: Date }>;
```

From src/core/types/index.ts:
```typescript
export interface XOAuthConfig {
  clientId: string;
  clientSecret: string;
  callbackUrl: string;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add callback URL constants to src/platforms/x/oauth.ts</name>
  <files>src/platforms/x/oauth.ts</files>
  <action>
Add three exported constants at the top of `src/platforms/x/oauth.ts` (after imports, before functions):

```typescript
/** Single source of truth for X OAuth callback URL. Used by setup flow and callback server. */
export const X_CALLBACK_URL = "http://127.0.0.1:18923/callback";
export const OAUTH_CALLBACK_PORT = 18923;
export const OAUTH_CALLBACK_HOSTNAME = "127.0.0.1";
```

Do NOT modify any existing functions. These constants will be imported by `setup-x-oauth.ts` (Plan 02), `oauth-callback-server.ts` (this plan Task 2), and other files that currently hardcode `https://example.com/callback`.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && grep -c "X_CALLBACK_URL\|OAUTH_CALLBACK_PORT\|OAUTH_CALLBACK_HOSTNAME" src/platforms/x/oauth.ts | grep -q "3" && bun run typecheck 2>&1 | tail -5</automated>
  </verify>
  <done>Three constants exported from src/platforms/x/oauth.ts. Typecheck passes with no new errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create oauth-callback-server.ts with Bun.serve ephemeral server</name>
  <files>src/cli/oauth-callback-server.ts</files>
  <action>
Create `src/cli/oauth-callback-server.ts` as a standalone module with the following exports:

**Types:**
```typescript
interface CallbackResult {
  code: string;
  state: string;
}

interface CallbackError {
  error: "timeout" | "state_mismatch" | "port_unavailable" | "missing_params";
  message: string;
}

type CallbackOutcome =
  | { ok: true; result: CallbackResult }
  | { ok: false; error: CallbackError };
```

**`startCallbackServer(expectedState: string, options: { port: number; hostname: string; timeoutMs: number }): Promise<CallbackOutcome>`**
- Uses `Bun.serve` (NOT `node:http` -- this is a Bun project per RESEARCH.md)
- Wraps entire Bun.serve in try/catch. On bind failure (port unavailable), resolve with `{ ok: false, error: { error: "port_unavailable", message: "Port {port} is in use. Cannot start OAuth callback server." } }`
- Sets a timeout timer (`setTimeout`) for `options.timeoutMs`. On timeout, call `server.stop()` and resolve with timeout error
- fetch handler:
  - Non-`/callback` paths: return `new Response("", { status: 404 })`
  - `/callback`: parse `code` and `state` from URL searchParams
  - Missing code or state: return `new Response("Missing parameters", { status: 400 })`
  - State mismatch (`state !== expectedState`): return `new Response("Invalid state parameter", { status: 403 })`
  - Valid callback: `clearTimeout(timeout)`, respond with SUCCESS_HTML first, then use `queueMicrotask` to `server.stop()` and resolve promise with `{ ok: true, result: { code, state } }`
- SUCCESS_HTML: minimal page with "Authorization complete! You can close this tab." and `setTimeout(()=>window.close(),3000)` script (from RESEARCH.md code example)

**`canOpenBrowser(): boolean`**
- Returns false if `process.env.SSH_CLIENT` or `process.env.SSH_TTY` is set
- Returns false on Linux if neither `DISPLAY` nor `WAYLAND_DISPLAY` is set
- Returns true otherwise

**`openBrowser(url: string): boolean`**
- Import `exec` from `node:child_process`
- `darwin`: `exec('open "${url}"')`
- `win32`: `exec('start "" "${url}"')`
- else: `exec('xdg-open "${url}"')`
- Wrap in try/catch, return true on success, false on failure

**`captureOAuthCallback(expectedState: string, options: { authUrl: string; timeoutMs: number }): Promise<CallbackOutcome>`**
- High-level orchestrator function that combines server + browser opening
- Import `OAUTH_CALLBACK_PORT` and `OAUTH_CALLBACK_HOSTNAME` from `../platforms/x/oauth.ts`
- Start callback server via `startCallbackServer(expectedState, { port: OAUTH_CALLBACK_PORT, hostname: OAUTH_CALLBACK_HOSTNAME, timeoutMs: options.timeoutMs })`
- If server started successfully (hasn't immediately resolved with port_unavailable), attempt to open browser:
  - If `canOpenBrowser()`, call `openBrowser(options.authUrl)` (fire-and-forget, don't block on failure)
- Await and return the server promise outcome

Note: The `captureOAuthCallback` function is the public API that `setup-x-oauth.ts` will call in Plan 02. Keep `startCallbackServer`, `openBrowser`, and `canOpenBrowser` exported for testability but the primary interface is `captureOAuthCallback`.

Implementation detail: Since `startCallbackServer` returns a Promise that only resolves on callback/timeout/bind-failure, and we need to open the browser AFTER the server is listening but BEFORE the promise resolves, structure it as follows:
1. Try to create the server (synchronous Bun.serve call in try/catch)
2. If bind fails, return port_unavailable immediately
3. If bind succeeds, open browser, then return the promise that resolves on callback/timeout

This means `startCallbackServer` needs to be restructured slightly from the simple Promise wrapper -- it should return `{ server: BunServer; promise: Promise<CallbackOutcome> }` or use a callback pattern. Alternatively, `captureOAuthCallback` can directly use `Bun.serve` instead of calling `startCallbackServer`. Choose the cleaner approach -- likely having `startCallbackServer` start the server and return the promise, and opening the browser happens inside `captureOAuthCallback` between server start and await. Use `Promise.withResolvers()` or a deferred pattern to separate server creation from resolution.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && bun run typecheck 2>&1 | tail -5 && test -f src/cli/oauth-callback-server.ts && grep -c "export" src/cli/oauth-callback-server.ts</automated>
  </verify>
  <done>
    - oauth-callback-server.ts exists with exports: startCallbackServer, captureOAuthCallback, openBrowser, canOpenBrowser
    - CallbackOutcome/CallbackResult/CallbackError types exported
    - Uses Bun.serve (not node:http)
    - Validates state parameter (CSRF prevention)
    - Handles timeout (2 min default)
    - Handles port unavailable gracefully
    - Typecheck passes
  </done>
</task>

</tasks>

<verification>
- `bun run typecheck` passes with no new errors
- `src/platforms/x/oauth.ts` exports X_CALLBACK_URL, OAUTH_CALLBACK_PORT, OAUTH_CALLBACK_HOSTNAME
- `src/cli/oauth-callback-server.ts` exists and exports captureOAuthCallback
- `grep -r "X_CALLBACK_URL" src/` shows the constant is importable
</verification>

<success_criteria>
- Callback server module is self-contained and can capture OAuth codes via localhost
- X callback URL constants exist as single source of truth
- State validation prevents CSRF attacks
- Port unavailable detection works (try/catch on Bun.serve)
- Timeout after 2 minutes resolves with error (not hang)
</success_criteria>

<output>
After completion, create `.planning/phases/27-x-oauth-callback-server/27-01-SUMMARY.md`
</output>
