---
phase: 29-testing-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [29-01]
files_modified:
  - src/platforms/handlers/x.handler.test.ts
autonomous: true
requirements: [TEST-03, TEST-04]

must_haves:
  truths:
    - "Thread checkpoint resume works: a retried thread skips already-posted tweets and continues from the checkpoint"
    - "Duplicate detection works: when XClient throws a 403 duplicate error during thread posting, the handler recovers the tweet ID from timeline and continues"
    - "Checkpoint persistence works: after each successful tweet in a thread, the DB receives a checkpoint write with threadProgress metadata"
    - "Interface compliance: XHandler.publish() returns the correct PlatformPublishResult shape for success, failure, and thread scenarios"
  artifacts:
    - path: "src/platforms/handlers/x.handler.test.ts"
      provides: "Thread checkpoint resume, duplicate recovery, checkpoint persistence, and XHandler publish flow tests"
      min_lines: 100
  key_links:
    - from: "src/platforms/handlers/x.handler.test.ts"
      to: "src/platforms/handlers/x.handler.ts"
      via: "imports XHandler, tests publish() method"
      pattern: "import.*XHandler"
    - from: "src/platforms/handlers/x.handler.test.ts"
      to: "src/platforms/__mocks__/clients.ts"
      via: "uses MockXClient for controlled tweet creation"
      pattern: "MockXClient"
---

<objective>
Create handler-level tests for XHandler covering thread checkpoint resume, duplicate detection/recovery, checkpoint persistence, and publish flow interface compliance.

Purpose: Validate the critical thread publishing resilience logic (Phases 26-28 fixes) with automated tests, using the mock infrastructure from Plan 01.
Output: x.handler.test.ts with thread checkpoint and interface compliance tests.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-testing-infrastructure/29-CONTEXT.md
@.planning/phases/29-testing-infrastructure/29-RESEARCH.md
@.planning/phases/29-testing-infrastructure/29-01-SUMMARY.md

@src/platforms/handlers/x.handler.ts
@src/platforms/__mocks__/clients.ts
@src/platforms/__mocks__/fixtures.ts
@src/trigger/publish-post.test.ts

<interfaces>
<!-- Key types from Plan 01 outputs -->

From src/platforms/__mocks__/clients.ts (created in Plan 01):
```typescript
export class MockXClient {
  async createTweet(params: { text: string; replyToId?: string; mediaIds?: string[] }): Promise<{ id: string; text: string; rateLimit: RateLimitInfo }>
  async getTimeline(params?: { maxResults?: number }): Promise<{ data: Array<{ id: string; text: string }> }>
  setFailure(error: Error): void
  clearFailure(): void
  getPostedTweets(): Array<{ id: string; text: string }>
  reset(): void
}
```

From src/platforms/handlers/x.handler.ts:
```typescript
export class XHandler implements PlatformPublisher {
  publish(db: DbConnection, post: PostRow, encKey: Buffer): Promise<PlatformPublishResult>
  // postThread is private -- test through publish()
}
// Top-level side-effect: registerHandler("x", XHandler)
```

From src/platforms/x/types.ts:
```typescript
export class XApiError extends Error { statusCode: number; body: unknown }
export class RateLimitError extends XApiError { rateLimit: RateLimitInfo }
```

From existing publish-post.test.ts (DB mock pattern):
```typescript
function buildMockDb(post) {
  const mockLimit = vi.fn().mockResolvedValue(post ? [post] : []);
  const mockWhere = vi.fn().mockReturnValue({ limit: mockLimit });
  const mockFrom = vi.fn().mockReturnValue({ where: mockWhere });
  const mockSelect = vi.fn().mockReturnValue({ from: mockFrom });
  const mockSetWhere = vi.fn().mockResolvedValue(undefined);
  const mockSet = vi.fn().mockReturnValue({ where: mockSetWhere });
  const mockUpdate = vi.fn().mockReturnValue({ set: mockSet });
  return { select: mockSelect, update: mockUpdate };
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create XHandler thread checkpoint and publish flow tests</name>
  <files>src/platforms/handlers/x.handler.test.ts</files>
  <behavior>
    - Single tweet publish: XHandler.publish() returns { status: "published", externalPostId: "tweet_1" } for content under 280 chars
    - Single tweet publish fails validation: content over 280 chars returns { status: "failed", error: "...N/280 characters..." }
    - Missing X credentials: returns { status: "failed", error: "X_CLIENT_ID or X_CLIENT_SECRET not set" }
    - Missing OAuth token: returns { status: "failed", error: "no_oauth_token" }
    - Thread publish success: JSON array content ["tweet1", "tweet2", "tweet3"] posts all 3, returns externalPostId of first tweet
    - Thread checkpoint persistence: after each successful tweet, DB update is called with threadProgress metadata
    - Thread resume from checkpoint: post with existing threadProgress metadata (posted: 2, tweetIds: ["t1","t2"]) only posts tweet 3
    - Duplicate detection: when createTweet throws XApiError(403, "duplicate content"), handler calls getTimeline to recover ID and continues
    - Checkpoint saved before error: when tweet 3 of 4 fails (after 2 succeed), checkpoint is saved with posted: 2 before the error propagates
  </behavior>
  <action>
Create `src/platforms/handlers/x.handler.test.ts`.

**Mocking strategy** (critical -- read pitfalls from RESEARCH.md):

1. Mock `@trigger.dev/sdk` at module level so `retry.onThrow` executes the callback directly (no retries) and `wait.until` resolves immediately. Use `logger` as no-ops. Pattern:
```typescript
vi.mock("@trigger.dev/sdk", () => ({
  retry: { onThrow: async (fn: () => Promise<unknown>) => fn() },
  wait: { until: async () => {} },
  logger: { info: () => {}, warn: () => {}, error: () => {} },
}));
```
Note: `retry.onThrow` in the REAL code wraps createTweet AND catches SkipRetryError. In tests, since we mock retry.onThrow to just execute the callback, the SkipRetryError will propagate up to the postThread catch block. This correctly tests the SkipRetryError unwrapping logic.

2. Mock `../../core/utils/publisher-factory.ts` to prevent side-effect handler registration:
```typescript
vi.mock("../../core/utils/publisher-factory.ts", () => ({ registerHandler: () => {} }));
```

3. Mock `../x/client.ts` to inject MockXClient. Use `vi.mock` with factory that returns MockXClient as XClient.

4. Mock `../x/oauth.ts` to provide stub oauth functions.

5. Mock `../../core/utils/crypto.ts` to make decrypt/encrypt pass-through (return input).

6. Mock `../x/media.ts` to return fake mediaIds.

7. Mock DB using the established Drizzle chain pattern from publish-post.test.ts. The mock DB needs:
   - `select().from(oauthTokens).where().limit()` returning a valid token
   - `select().from(posts).where().limit()` returning recent posts (for duplicate check)
   - `update(posts).set().where()` capturing checkpoint writes
   - `execute()` for token refresh SQL (can be no-op)

8. Set `process.env.X_CLIENT_ID` and `process.env.X_CLIENT_SECRET` in `beforeEach`.

**Test structure:**

```
describe("XHandler")
  describe("publish() - single tweet")
    - returns published with externalPostId
    - returns failed for oversized content
    - returns failed when X credentials missing
    - returns failed when no OAuth token
  describe("publish() - thread")
    - posts all tweets in order with correct replyToId chaining
    - saves checkpoint after each tweet (verify DB update calls)
    - resumes from checkpoint (metadata.threadProgress present)
  describe("publish() - thread error handling")
    - recovers tweet ID on duplicate error (403)
    - saves checkpoint before propagating non-duplicate error
```

**Important:** Test through the public `publish()` method, NOT private `postThread()`. Do NOT cast to `any` to access private methods. Thread behavior is triggered by providing JSON array content with 2+ tweets.

Build a `buildPost()` helper that creates a minimal PostRow matching the schema shape (id, userId, content, platform, status, metadata, mediaUrls, etc.).

Set `process.env.X_CLIENT_ID = "test_id"` and `process.env.X_CLIENT_SECRET = "test_secret"` in `beforeEach`, clean up in `afterEach`.
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && npx vitest run src/platforms/handlers/x.handler.test.ts --reporter=verbose 2>&1 | tail -25</automated>
  </verify>
  <done>XHandler tests cover: single tweet publish (success + validation failure + missing credentials + missing token), thread publish (ordered posting + checkpoint persistence + resume from checkpoint), thread error handling (duplicate recovery + checkpoint-before-error). All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and verify all requirements</name>
  <files></files>
  <action>
Run the complete test suite to verify no regressions:
1. `npx vitest run` -- all tests pass (existing 191 + new tests)
2. `bun run typecheck` -- no new type errors from test files
3. Verify requirement coverage:
   - TEST-01: Confirmed by path alias resolution working in all test files (Vitest 4.x reads tsconfig.json)
   - TEST-02: `src/platforms/__mocks__/clients.ts` exports MockXClient, MockLinkedInClient, MockInstagramClient, MockTikTokClient
   - TEST-03: `x.handler.test.ts` validates publish() behavioral contracts (preconditions, postconditions, error handling)
   - TEST-04: `tweet-validator.test.ts` covers countTweetChars edge cases + `x.handler.test.ts` covers thread checkpoint resume/duplicate detection
   - DOC-03: `publisher.ts` has JSDoc behavioral contracts with @precondition/@postcondition/@throws/@sideeffect

If any tests fail, diagnose and fix. Common issues:
- Module resolution: ensure imports use `.ts` extensions (Bun requirement)
- Side-effect registration: ensure publisher-factory mock prevents handler registry pollution
- Trigger.dev SDK: ensure retry.onThrow mock executes callback directly
  </action>
  <verify>
    <automated>cd /home/hybridz/Projects/post-shit-now && npx vitest run --reporter=verbose 2>&1 | grep -E "Tests|Test Files" | tail -5</automated>
  </verify>
  <done>Full test suite passes with 0 failures. Type check passes. All 5 requirements (TEST-01 through TEST-04, DOC-03) verified.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes all tests (existing + new) with 0 failures
- `bun run typecheck` exits 0
- `x.handler.test.ts` has tests for: single tweet, thread posting, checkpoint resume, duplicate recovery, checkpoint-before-error
- Thread resume test verifies only unpublished tweets are posted (createTweet called once for tweet 3, not for tweets 1-2)
- Duplicate recovery test verifies getTimeline is called and recovered ID is used
</verification>

<success_criteria>
- XHandler thread checkpoint tests pass: resume skips already-posted tweets, duplicate 403 triggers timeline recovery
- Interface compliance verified: publish() returns correct PlatformPublishResult shapes
- Full test suite (200+ tests) passes with no regressions
- All 5 requirement IDs (TEST-01-04, DOC-03) have corresponding verified artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/29-testing-infrastructure/29-02-SUMMARY.md`
</output>
